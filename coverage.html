
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cateng: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/atlasgurus/rulestone/cateng/builder.go (87.8%)</option>
				
				<option value="file1">github.com/atlasgurus/rulestone/cateng/category_engine.go (90.7%)</option>
				
				<option value="file2">github.com/atlasgurus/rulestone/condition/condition.go (54.3%)</option>
				
				<option value="file3">github.com/atlasgurus/rulestone/condition/condition_utils.go (0.0%)</option>
				
				<option value="file4">github.com/atlasgurus/rulestone/condition/factory.go (81.5%)</option>
				
				<option value="file5">github.com/atlasgurus/rulestone/condition/rule.go (92.3%)</option>
				
				<option value="file6">github.com/atlasgurus/rulestone/engine/engine_api.go (76.5%)</option>
				
				<option value="file7">github.com/atlasgurus/rulestone/engine/engine_impl.go (64.7%)</option>
				
				<option value="file8">github.com/atlasgurus/rulestone/engine/lookups.go (59.1%)</option>
				
				<option value="file9">github.com/atlasgurus/rulestone/immutable/set.go (68.5%)</option>
				
				<option value="file10">github.com/atlasgurus/rulestone/objectmap/object_attribute_map.go (88.2%)</option>
				
				<option value="file11">github.com/atlasgurus/rulestone/types/types.go (56.9%)</option>
				
				<option value="file12">github.com/atlasgurus/rulestone/utils/test_utilities.go (31.6%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cateng

import (
        "fmt"
        "github.com/atlasgurus/rulestone/condition"
        "github.com/atlasgurus/rulestone/immutable"
        "github.com/atlasgurus/rulestone/types"
        "github.com/zyedidia/generic/hashmap"
        "sort"
)

type CatSetMask struct {
        Mask   types.Mask
        Index1 types.Category
}

// SliceMap is a slice that behaves like a map with positive integer keys.
type SliceMap[T any] []T

// Set sets a value at an arbitrary index in the slice,
// automatically expanding the slice if needed.
func (s SliceMap[T]) Set(index int, value T) SliceMap[T] <span class="cov8" title="1">{
        if index &lt; 0 </span><span class="cov0" title="0">{
                panic("")</span>
        }

        // If the index is within the current length of the slice, just set the value.
        <span class="cov8" title="1">if index &lt; len(s) </span><span class="cov8" title="1">{
                s[index] = value
                return s
        }</span>

        // If the index is within the current capacity of the slice, expand the length and set the value.
        <span class="cov8" title="1">if index &lt; cap(s) </span><span class="cov0" title="0">{
                result := s[0 : index+1]
                result[index] = value
                return result
        }</span>

        // If the index is larger than the current capacity, create a new slice and copy values.
        <span class="cov8" title="1">newSlice := make([]T, index+1)
        copy(newSlice, s)
        newSlice[index] = value
        return newSlice</span>
}

type CatSetMaskArray struct {
        //val map[types.Category][]*CatSetMask
        val0 SliceMap[[]*CatSetMask]
        val1 SliceMap[[]*CatSetMask]
}

func (array *CatSetMaskArray) Get(index types.Category) []*CatSetMask <span class="cov8" title="1">{
        if index &lt; types.MaxCategory </span><span class="cov8" title="1">{
                if int(index) &lt; len(array.val0) </span><span class="cov8" title="1">{
                        return array.val0[index]
                }</span> else<span class="cov8" title="1"> {
                        return nil
                }</span>
        } else<span class="cov8" title="1"> {
                index -= types.MaxCategory
                if int(index) &lt; len(array.val1) </span><span class="cov8" title="1">{
                        return array.val1[index]
                }</span> else<span class="cov8" title="1"> {
                        return nil
                }</span>
        }
}

func (array *CatSetMaskArray) Set(index types.Category, masks []*CatSetMask) <span class="cov8" title="1">{
        if index &lt; types.MaxCategory </span><span class="cov8" title="1">{
                array.val0 = array.val0.Set(int(index), masks)
        }</span> else<span class="cov8" title="1"> {
                index -= types.MaxCategory
                array.val1 = array.val1.Set(int(index), masks)
        }</span>
}

type RuleFilterRec struct {
        RuleIndex condition.RuleIndexType
        RuleId    condition.RuleIdType
}

type CatSetFilter struct {
        CatSetIndex1 types.Category
        RuleSet      []*RuleFilterRec
        CatSetMasks  []*CatSetMask
}

type FilterTables struct {
        CatToCatSetMask   *CatSetMaskArray
        CatSetFilters     []*CatSetFilter
        BuilderMetrics    BuilderMetrics
        RuleRecs          []*condition.RuleRec
        NegCats           map[types.Category]types.Category
        DefaultCategories map[types.Category]int
        DefaultCatList    []types.Category
}

type CatFilterSetType struct {
        CatSetIndex1 types.Category
        AndSet       types.AndOrSet
}

type CatSetRec struct {
        CatFilterSet CatFilterSetType
        RuleSet      []*RuleFilterRec
        CatSetMasks  []*CatSetMask
}

type CatFilter struct {
        AndSet types.AndOrSet
}

type BuilderMetrics struct {
        OrSetsRemoved    uint
        AndSetsRemoved   uint
        OrSetsInlined    uint
        AndOrSetsInlined uint
        AndOrSetsGCed    uint
}

type Options struct {
        OrOptimizationFreqThreshold  uint
        AndOptimizationFreqThreshold uint
        Verbose                      bool
}

type FilterBuilder struct {
        RuleRepo      *condition.RuleRepo
        CatFilterSets []*CatSetRec
        CatSetMap     *hashmap.Map[types.AndOrSet, *CatSetRec]
        NegCats       map[types.Category]types.Category
        RuleRecs      []*condition.RuleRec
        options       *Options
        metrics       BuilderMetrics
}

func (fb *FilterBuilder) registerAndSet(andSet types.AndOrSet) *CatSetRec <span class="cov8" title="1">{
        result, ok := fb.CatSetMap.Get(andSet)
        if !ok </span><span class="cov8" title="1">{
                result = &amp;CatSetRec{CatFilterSet: CatFilterSetType{types.Category(len(fb.CatFilterSets) + 1), andSet}, RuleSet: []*RuleFilterRec{}, CatSetMasks: []*CatSetMask{}}
                fb.CatFilterSets = append(fb.CatFilterSets, result)
                fb.CatSetMap.Put(andSet, result)
        }</span>
        <span class="cov8" title="1">return result</span>
}

func (fb *FilterBuilder) registerNegativeCat(cat types.Category) types.Category <span class="cov8" title="1">{
        negCat, ok := fb.NegCats[cat]
        if !ok </span><span class="cov8" title="1">{
                negCat = cat + types.MaxCategory
                fb.NegCats[cat] = negCat
        }</span>
        <span class="cov8" title="1">return negCat</span>
}

func (fb *FilterBuilder) replaceFilterSet(set types.AndOrSet, with types.AndOrSet) bool <span class="cov8" title="1">{
        if !set.Equals(with) </span><span class="cov8" title="1">{
                csr, ok := fb.CatSetMap.Get(set)
                if !ok </span><span class="cov0" title="0">{
                        panic("Unregistered set.")</span>
                }
                <span class="cov8" title="1">newCsr :=
                        &amp;CatSetRec{
                                CatFilterSet: CatFilterSetType{
                                        CatSetIndex1: csr.CatFilterSet.CatSetIndex1,
                                        AndSet:       with},
                                RuleSet:     csr.RuleSet,
                                CatSetMasks: csr.CatSetMasks}
                fb.CatFilterSets[newCsr.CatFilterSet.CatSetIndex1-1] = newCsr
                fb.CatSetMap.Remove(set)
                fb.CatSetMap.Put(with, newCsr)
                return true</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (fb *FilterBuilder) unregisterFilterSet(set types.AndOrSet) <span class="cov8" title="1">{
        csr, ok := fb.CatSetMap.Get(set)
        if !ok </span><span class="cov0" title="0">{
                panic("Unregistered set.")</span>
        }
        <span class="cov8" title="1">fb.CatFilterSets[csr.CatFilterSet.CatSetIndex1-1] = nil
        fb.CatSetMap.Remove(set)</span>
}

func (fb *FilterBuilder) buildCatSetFilterForAndOrSets(set *types.AndOrSet) <span class="cov0" title="0">{
        catFilter := CatFilter{*set}
        catSetRec := fb.registerAndSet(catFilter.AndSet)
        catSetRec.RuleSet = append(catSetRec.RuleSet,
                &amp;RuleFilterRec{1, 0})
}</span>

func (fb *FilterBuilder) buildCatSetFiltersForAndOrSets(andOrSets []*types.AndOrSet) <span class="cov0" title="0">{
        for _, fs := range andOrSets </span><span class="cov0" title="0">{
                fb.buildCatSetFilterForAndOrSets(fs)
        }</span>
}

func collectCategories(c condition.Condition) []types.Category <span class="cov0" title="0">{
        switch c.GetKind() </span>{
        case condition.CategoryCondKind:<span class="cov0" title="0">
                return []types.Category{c.(*condition.CategoryCond).Cat}</span>
        default:<span class="cov0" title="0">
                var result []types.Category
                for _, v := range c.GetOperands() </span><span class="cov0" title="0">{
                        result = append(result, collectCategories(v)...)
                }</span>
                <span class="cov0" title="0">return result</span>
        }
}

func (fb *FilterBuilder) buildCatSetFilters(repo *condition.RuleRepo) <span class="cov8" title="1">{
        fb.RuleRecs = computeRuleRecs(repo.Rules)
        for _, c := range fb.RuleRecs </span><span class="cov8" title="1">{
                fb.buildCatSetFilter(c.Rule, c.RuleIndex)
        }</span>
}

func computeRuleRecs(rules []*condition.Rule) []*condition.RuleRec <span class="cov8" title="1">{
        var nextIndex condition.RuleIndexType = -1
        var result []*condition.RuleRec
        for _, rule := range rules </span><span class="cov8" title="1">{
                nextIndex += 1
                result = append(result, &amp;condition.RuleRec{Rule: rule, RuleIndex: nextIndex})
        }</span>
        <span class="cov8" title="1">return result</span>
}

func (fb *FilterBuilder) computeCatFilter(cond condition.Condition) CatFilter <span class="cov8" title="1">{
        switch cond.GetKind() </span>{
        case condition.CategoryCondKind:<span class="cov8" title="1">
                cat := cond.(*condition.CategoryCond).Cat
                //if cat &lt; 0 {
                //panic("Invalid category (&lt; 0)")
                //}
                s1 := immutable.Of[types.Category](cat)
                s2 := immutable.Of[immutable.Set[types.Category]](*s1)
                return CatFilter{types.AndOrSet(*s2)}</span>
        case condition.AndCondKind:<span class="cov8" title="1">
                return fb.processAndOp(cond)</span>
        case condition.OrCondKind:<span class="cov8" title="1">
                return fb.processOrOp(cond)</span>
        case condition.NotCondKind:<span class="cov8" title="1">
                return fb.processNotOp(cond.GetOperands()[0])</span>
        }
        <span class="cov0" title="0">return CatFilter{}</span>
}

func (fb *FilterBuilder) buildCatSetFilter(rule *condition.Rule, ruleIndex condition.RuleIndexType) <span class="cov8" title="1">{
        catFilter := fb.computeCatFilter(rule.Cond)
        catSetRec := fb.registerAndSet(catFilter.AndSet)
        catSetRec.RuleSet = append(
                catSetRec.RuleSet, &amp;RuleFilterRec{RuleIndex: ruleIndex, RuleId: rule.RuleId})
}</span>

func (fb *FilterBuilder) processAndOp(cond condition.Condition) CatFilter <span class="cov8" title="1">{
        if len(cond.GetOperands()) &gt; 0 </span><span class="cov8" title="1">{
                operands := types.MapSlice(cond.GetOperands(), fb.computeCatFilter)
                return types.Reduce(operands[1:], fb.andFilters, operands[0])
        }</span> else<span class="cov0" title="0"> {
                return CatFilter{AndSet: types.EmptyAndOrSet}
        }</span>
}

func (fb *FilterBuilder) processOrOp(cond condition.Condition) CatFilter <span class="cov8" title="1">{
        if len(cond.GetOperands()) &gt; 0 </span><span class="cov8" title="1">{
                operands := types.MapSlice(cond.GetOperands(), fb.computeCatFilter)
                return types.Reduce(operands[1:], fb.orFilters, operands[0])
        }</span> else<span class="cov0" title="0"> {
                return CatFilter{AndSet: types.EmptyAndOrSet}
        }</span>
}

func (fb *FilterBuilder) processNotOp(cond condition.Condition) CatFilter <span class="cov8" title="1">{
        switch cond.GetKind() </span>{
        case condition.CategoryCondKind:<span class="cov8" title="1">
                cat := cond.(*condition.CategoryCond).Cat
                if cat &lt; 0 </span><span class="cov0" title="0">{
                        panic("Invalid category (&lt; 0)")</span>
                }
                // Substitute the negation of the category with its negative category
                <span class="cov8" title="1">negCat := fb.registerNegativeCat(cat)
                return fb.computeCatFilter(condition.NewCategoryCond(negCat))</span>
        case condition.AndCondKind:<span class="cov0" title="0">
                return fb.computeCatFilter(
                        condition.NewOrCond(
                                types.MapSlice(cond.GetOperands(), func(a condition.Condition) condition.Condition </span><span class="cov0" title="0">{
                                        return condition.NewNotCond(a)
                                }</span>)...))
        case condition.OrCondKind:<span class="cov0" title="0">
                return fb.computeCatFilter(
                        condition.NewAndCond(
                                types.MapSlice(cond.GetOperands(), func(a condition.Condition) condition.Condition </span><span class="cov0" title="0">{
                                        return condition.NewNotCond(a)
                                }</span>)...))
        case condition.NotCondKind:<span class="cov0" title="0">
                return fb.computeCatFilter(cond)</span>
        default:<span class="cov0" title="0">
                panic("Unexpected condition kind")</span>
        }
}

func (fb *FilterBuilder) andFilters(a CatFilter, b CatFilter) CatFilter <span class="cov8" title="1">{
        andSet := a.AndSet.Union(b.AndSet)
        if andSet.Size() &gt; 64 </span><span class="cov0" title="0">{
                longAndOrSet := andSet.ToSlice()
                part1AndOrSet := immutable.Of(longAndOrSet[:64]...)
                part1CatSetRec := fb.registerAndSet(types.AndOrSet(*part1AndOrSet))
                part2AndOrSet := immutable.Of(
                        append(longAndOrSet[64:], *immutable.Of(-part1CatSetRec.CatFilterSet.CatSetIndex1))...)
                return CatFilter{AndSet: types.AndOrSet(*part2AndOrSet)}
        }</span> else<span class="cov8" title="1"> {
                return CatFilter{AndSet: andSet}
        }</span>
}

func (fb *FilterBuilder) orFilters(a CatFilter, b CatFilter) CatFilter <span class="cov8" title="1">{
        aSlice := a.AndSet.ToSlice()
        bSlice := b.AndSet.ToSlice()
        if len(aSlice) == 0 </span><span class="cov0" title="0">{
                return CatFilter{AndSet: b.AndSet}
        }</span> else<span class="cov8" title="1"> if len(bSlice) == 0 </span><span class="cov0" title="0">{
                return CatFilter{AndSet: a.AndSet}
        }</span> else<span class="cov8" title="1"> if len(aSlice) == 1 &amp;&amp; len(bSlice) == 1 </span><span class="cov8" title="1">{
                s := immutable.Of(*(immutable.Of(append(aSlice[0].ToSlice(), bSlice[0].ToSlice()...)...)))
                return CatFilter{AndSet: types.AndOrSet(*s)}
        }</span> else<span class="cov0" title="0"> {
                aCatSetRec := fb.registerAndSet(a.AndSet)
                bCatSetRec := fb.registerAndSet(b.AndSet)
                s := immutable.Of(*(immutable.Of(
                        -aCatSetRec.CatFilterSet.CatSetIndex1,
                        -bCatSetRec.CatFilterSet.CatSetIndex1)))
                return CatFilter{AndSet: types.AndOrSet(*s)}
        }</span>
}

func NewFilterBuilder(repo *condition.RuleRepo, options *Options) *FilterBuilder <span class="cov8" title="1">{
        if options == nil </span><span class="cov8" title="1">{
                options = &amp;Options{}
        }</span>
        <span class="cov8" title="1">result := FilterBuilder{RuleRepo: repo, CatFilterSets: []*CatSetRec{},
                CatSetMap: types.NewHashMap[types.AndOrSet, *CatSetRec](),
                options:   options,
                NegCats:   make(map[types.Category]types.Category)}
        result.buildCatSetFilters(repo)
        return &amp;result</span>
}

func (fb *FilterBuilder) optimize() <span class="cov8" title="1">{
        if fb.options.OrOptimizationFreqThreshold &gt; 0 </span><span class="cov8" title="1">{
                for </span><span class="cov8" title="1">{
                        removeCount := fb.optimiseOrSets()
                        if removeCount &lt;= 0 </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov8" title="1">fb.metrics.OrSetsRemoved += removeCount</span>
                }
                <span class="cov8" title="1">if fb.options.Verbose </span><span class="cov8" title="1">{
                        fmt.Printf("optimizedOrSets removed %d\n", fb.metrics.OrSetsRemoved)
                }</span>
        }
        <span class="cov8" title="1">if fb.options.AndOptimizationFreqThreshold &gt; 0 </span><span class="cov8" title="1">{
                for </span><span class="cov8" title="1">{
                        removeCount := fb.optimiseAndSets()
                        if removeCount &lt;= 0 </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov8" title="1">fb.metrics.AndSetsRemoved += removeCount</span>
                }
                <span class="cov8" title="1">if fb.options.Verbose </span><span class="cov8" title="1">{
                        fmt.Printf("optimizedAndOrSets removed %d\n", fb.metrics.AndSetsRemoved)
                }</span>
        }
        <span class="cov8" title="1">fb.inlineOrSets()
        if fb.options.Verbose </span><span class="cov8" title="1">{
                fmt.Printf("OrSetsInlined %d\n", fb.metrics.OrSetsInlined)
        }</span>
        <span class="cov8" title="1">fb.inlineAndOrSets()
        if fb.options.Verbose </span><span class="cov8" title="1">{
                fmt.Printf("AndOrSetsInlined %d\n", fb.metrics.AndOrSetsInlined)
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; 10; i++ </span><span class="cov8" title="1">{
                fb.gcAndOrSets()
        }</span>
        <span class="cov8" title="1">if fb.options.Verbose </span><span class="cov8" title="1">{
                fmt.Printf("AndOrSetsGCed %d\n", fb.metrics.AndOrSetsGCed)
        }</span>
}

type catPair struct {
        cat1 types.Category
        cat2 types.Category
}

type pairFreq struct {
        cp   catPair
        freq uint
}

func (fb *FilterBuilder) optimiseOrSets() uint <span class="cov8" title="1">{
        catSetFreq := fb.computeOrSetFreq()
        countOfSetsRemoved := uint(0)

        for _, csr := range fb.CatFilterSets </span><span class="cov8" title="1">{
                if csr != nil </span><span class="cov8" title="1">{
                        var newAndSet []immutable.Set[types.Category]
                        csr.CatFilterSet.AndSet.Each(func(s immutable.Set[types.Category]) </span><span class="cov8" title="1">{
                                catsFreq := sortCatSetFreq(s, catSetFreq)

                                newOrSet := s.ToHashSet()
                                for _, pf := range catsFreq </span><span class="cov8" title="1">{
                                        if pf.freq &gt; fb.options.OrOptimizationFreqThreshold &amp;&amp;
                                                newOrSet.Has(pf.cp.cat1) &amp;&amp;
                                                newOrSet.Has(pf.cp.cat2) </span><span class="cov8" title="1">{
                                                s := immutable.Of(*(immutable.Of(pf.cp.cat1, pf.cp.cat2)))
                                                newSetRec := fb.registerAndSet(types.AndOrSet(*s))
                                                if newSetRec.CatFilterSet.CatSetIndex1 != csr.CatFilterSet.CatSetIndex1 </span><span class="cov8" title="1">{
                                                        newOrSet.Remove(pf.cp.cat1)
                                                        newOrSet.Remove(pf.cp.cat2)
                                                        newOrSet.Put(-newSetRec.CatFilterSet.CatSetIndex1)
                                                        countOfSetsRemoved++
                                                }</span>
                                                <span class="cov8" title="1">break</span>
                                        }
                                }

                                <span class="cov8" title="1">newAndSet = append(newAndSet, *immutable.FromHashSet(&amp;newOrSet))</span>
                        })
                        <span class="cov8" title="1">fb.replaceFilterSet(csr.CatFilterSet.AndSet, types.AndOrSet(*immutable.Of(newAndSet...)))</span>
                }
        }
        <span class="cov8" title="1">return countOfSetsRemoved</span>
}

func (fb *FilterBuilder) computeSyntheticCatFreq() *hashmap.Map[types.Category, uint] <span class="cov8" title="1">{
        result := types.NewHashMap[types.Category, uint]()
        for _, csr := range fb.CatFilterSets </span><span class="cov8" title="1">{
                if csr != nil </span><span class="cov8" title="1">{
                        csr.CatFilterSet.AndSet.Each(func(s immutable.Set[types.Category]) </span><span class="cov8" title="1">{
                                s.Each(func(c types.Category) </span><span class="cov8" title="1">{
                                        if c &lt; 0 </span><span class="cov8" title="1">{
                                                count, _ := result.Get(c)
                                                result.Put(c, count+1)
                                        }</span>
                                })
                        })
                }
        }
        <span class="cov8" title="1">return result</span>
}

func (fb *FilterBuilder) inlineAndOrSets() <span class="cov8" title="1">{
        catSetFreq := fb.computeSyntheticCatFreq()

        for _, csr := range fb.CatFilterSets </span><span class="cov8" title="1">{
                if csr != nil </span><span class="cov8" title="1">{
                        andOrSet := csr.CatFilterSet.AndSet
                        newAndOrSet := fb.inlineAndOrSet(andOrSet, catSetFreq)
                        fb.replaceFilterSet(andOrSet, types.AndOrSet(*immutable.Of(newAndOrSet...)))
                }</span>
        }
}

func (fb *FilterBuilder) gcAndOrSets() <span class="cov8" title="1">{
        catSetFreq := fb.computeSyntheticCatFreq()

        for index1, csr := range fb.CatFilterSets </span><span class="cov8" title="1">{
                if csr != nil &amp;&amp; len(csr.RuleSet) == 0 </span><span class="cov8" title="1">{
                        freq, _ := catSetFreq.Get(types.Category(-index1 - 1))
                        if freq == 0 </span><span class="cov8" title="1">{
                                fb.metrics.AndOrSetsGCed++
                                fb.unregisterFilterSet(csr.CatFilterSet.AndSet)
                        }</span>
                }
        }
}

func (fb *FilterBuilder) inlineOrSets() <span class="cov8" title="1">{
        catSetFreq := fb.computeSyntheticCatFreq()

        for _, csr := range fb.CatFilterSets </span><span class="cov8" title="1">{
                if csr != nil </span><span class="cov8" title="1">{
                        andOrSet := csr.CatFilterSet.AndSet
                        var newS []immutable.Set[types.Category]
                        andOrSet.Each(func(s immutable.Set[types.Category]) </span><span class="cov8" title="1">{
                                newS = append(newS, *immutable.Of(fb.inlineOrSet(s, catSetFreq)...))
                        }</span>)
                        <span class="cov8" title="1">fb.replaceFilterSet(andOrSet, types.AndOrSet(*immutable.Of(newS...)))</span>
                }
        }
}

func sortCatSetFreq(s immutable.Set[types.Category], catSetFreq *hashmap.Map[immutable.Set[types.Category], uint]) []pairFreq <span class="cov8" title="1">{
        cats := s.ToSlice()
        var catsFreq []pairFreq
        for i, c1 := range cats </span><span class="cov8" title="1">{
                for _, c2 := range cats[i+1:] </span><span class="cov8" title="1">{
                        cp := immutable.Of(c1, c2)
                        freq, _ := catSetFreq.Get(*cp)
                        catsFreq = append(catsFreq, pairFreq{cp: catPair{cat1: c1, cat2: c2}, freq: freq})
                }</span>
        }
        <span class="cov8" title="1">sort.Slice(catsFreq, func(i, j int) bool </span><span class="cov8" title="1">{
                return catsFreq[i].freq &gt; catsFreq[j].freq
        }</span>)
        <span class="cov8" title="1">return catsFreq</span>
}

type orPair struct {
        orSet1 immutable.Set[types.Category]
        orSet2 immutable.Set[types.Category]
}

type orPairFreq struct {
        cp   orPair
        freq uint
}

func (fb *FilterBuilder) optimiseAndSets() uint <span class="cov8" title="1">{
        orSetFreq := fb.computeAndSetFreq()
        countOfSetsRemoved := uint(0)

        for _, csr := range fb.CatFilterSets </span><span class="cov8" title="1">{
                if csr != nil </span><span class="cov8" title="1">{
                        orFreq := sortOrSetFreq(csr, orSetFreq)

                        newAndSet := csr.CatFilterSet.AndSet.ToHashSet()

                        for _, pf := range orFreq </span><span class="cov8" title="1">{
                                if pf.freq &gt; fb.options.AndOptimizationFreqThreshold &amp;&amp;
                                        newAndSet.Has(pf.cp.orSet1) &amp;&amp;
                                        newAndSet.Has(pf.cp.orSet2) </span><span class="cov8" title="1">{
                                        s := immutable.Of(pf.cp.orSet1, pf.cp.orSet2)
                                        newSetRec := fb.registerAndSet(types.AndOrSet(*s))
                                        if newSetRec.CatFilterSet.CatSetIndex1 != csr.CatFilterSet.CatSetIndex1 </span><span class="cov8" title="1">{
                                                newAndSet.Remove(pf.cp.orSet1)
                                                newAndSet.Remove(pf.cp.orSet2)
                                                newAndSet.Put(*immutable.Of(-newSetRec.CatFilterSet.CatSetIndex1))
                                                countOfSetsRemoved++
                                        }</span>
                                        <span class="cov8" title="1">break</span>
                                }
                        }

                        <span class="cov8" title="1">fb.replaceFilterSet(csr.CatFilterSet.AndSet, types.AndOrSet(*immutable.FromHashSet(&amp;newAndSet)))</span>
                }
        }
        //fmt.Printf("optimizedAndSets removed %d\n", countOfSetsRemoved)
        <span class="cov8" title="1">return countOfSetsRemoved</span>
}

func sortOrSetFreq(csr *CatSetRec, orSetFreq *hashmap.Map[immutable.Set[immutable.Set[types.Category]], uint]) []orPairFreq <span class="cov8" title="1">{
        var orFreq []orPairFreq
        orSets := csr.CatFilterSet.AndSet.ToSlice()
        for i, orSet1 := range orSets </span><span class="cov8" title="1">{
                for j := i + 1; j &lt; len(orSets); j++ </span><span class="cov8" title="1">{
                        orSet2 := orSets[j]
                        cp := immutable.Of(orSet1, orSet2)
                        freq, _ := orSetFreq.Get(*cp)
                        orFreq = append(orFreq, orPairFreq{cp: orPair{orSet1: orSet1, orSet2: orSet2}, freq: freq})
                }</span>
        }

        <span class="cov8" title="1">sort.Slice(orFreq, func(i, j int) bool </span><span class="cov8" title="1">{
                if orFreq[i].freq == orFreq[j].freq </span><span class="cov8" title="1">{
                        return orFreq[i].cp.orSet1.GetHash()^orFreq[i].cp.orSet2.GetHash() &gt;
                                orFreq[j].cp.orSet1.GetHash()^orFreq[j].cp.orSet2.GetHash()
                }</span> else<span class="cov8" title="1"> {
                        return orFreq[i].freq &gt; orFreq[j].freq
                }</span>
        })
        <span class="cov8" title="1">return orFreq</span>
}

func (fb *FilterBuilder) computeOrSetFreq() *hashmap.Map[immutable.Set[types.Category], uint] <span class="cov8" title="1">{
        result := types.NewHashMap[immutable.Set[types.Category], uint]()
        for _, csr := range fb.CatFilterSets </span><span class="cov8" title="1">{
                if csr != nil </span><span class="cov8" title="1">{
                        csr.CatFilterSet.AndSet.Each(func(s immutable.Set[types.Category]) </span><span class="cov8" title="1">{
                                cats := s.ToSlice()
                                for i, c1 := range cats </span><span class="cov8" title="1">{
                                        for j := i + 1; j &lt; len(cats); j++ </span><span class="cov8" title="1">{
                                                c2 := cats[j]
                                                cp := immutable.Of(c1, c2)
                                                count, _ := result.Get(*cp)
                                                result.Put(*cp, count+1)
                                        }</span>
                                }
                        })
                }
        }
        <span class="cov8" title="1">return result</span>
}

func (fb *FilterBuilder) computeAndSetFreq() *hashmap.Map[immutable.Set[immutable.Set[types.Category]], uint] <span class="cov8" title="1">{
        result := types.NewHashMap[immutable.Set[immutable.Set[types.Category]], uint]()
        for _, csr := range fb.CatFilterSets </span><span class="cov8" title="1">{
                if csr != nil </span><span class="cov8" title="1">{
                        orSets := csr.CatFilterSet.AndSet.ToSlice()
                        for i, s1 := range orSets </span><span class="cov8" title="1">{
                                for j := i + 1; j &lt; len(orSets); j++ </span><span class="cov8" title="1">{
                                        s2 := orSets[j]
                                        cp := immutable.Of(s1, s2)
                                        count, _ := result.Get(*cp)
                                        result.Put(*cp, count+1)
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return result</span>
}

func (fb *FilterBuilder) buildFilterTables() FilterTables <span class="cov8" title="1">{
        result := FilterTables{CatToCatSetMask: fb.computeCatToRules(),
                CatSetFilters: types.MapSlice(
                        fb.CatFilterSets,
                        func(csr *CatSetRec) *CatSetFilter </span><span class="cov8" title="1">{
                                if csr == nil </span><span class="cov8" title="1">{
                                        return nil
                                }</span> else<span class="cov8" title="1"> {
                                        return &amp;CatSetFilter{
                                                CatSetIndex1: csr.CatFilterSet.CatSetIndex1,
                                                RuleSet:      csr.RuleSet,
                                                CatSetMasks:  csr.CatSetMasks}
                                }</span>
                        })}

        <span class="cov8" title="1">result.BuilderMetrics = fb.metrics
        result.RuleRecs = fb.RuleRecs
        result.NegCats = fb.NegCats
        result.DefaultCategories = make(map[types.Category]int)

        for cat := range fb.NegCats </span><span class="cov8" title="1">{
                result.DefaultCategories[cat] = len(result.DefaultCategories)
                result.DefaultCatList = append(result.DefaultCatList, cat)
        }</span>

        <span class="cov8" title="1">return result</span>
}

func (fb *FilterBuilder) computeCatToRules() *CatSetMaskArray <span class="cov8" title="1">{
        var result CatSetMaskArray

        setCatSetMask := func(csr *CatSetRec, mask types.Mask, cat types.Category) </span><span class="cov8" title="1">{
                catSetMask := CatSetMask{
                        Index1: csr.CatFilterSet.CatSetIndex1,
                        Mask:   mask,
                }

                if cat &lt; 0 </span><span class="cov8" title="1">{
                        catSetIndex1 := -cat
                        catFilterSet := fb.CatFilterSets[catSetIndex1-1]
                        catFilterSet.CatSetMasks = append(catFilterSet.CatSetMasks, &amp;catSetMask)
                }</span> else<span class="cov8" title="1"> {
                        result.Set(cat, append(result.Get(cat), &amp;catSetMask))
                }</span>
        }

        <span class="cov8" title="1">for _, csr := range fb.CatFilterSets </span><span class="cov8" title="1">{
                if csr != nil </span><span class="cov8" title="1">{
                        bitMask := types.Mask(1)
                        andSet := csr.CatFilterSet.AndSet.ToSlice()
                        if len(andSet) &gt; 0 </span><span class="cov8" title="1">{
                                head := andSet[0]
                                for _, orSet := range andSet[1:] </span><span class="cov8" title="1">{
                                        for _, ct := range orSet.ToSlice() </span><span class="cov8" title="1">{
                                                setCatSetMask(csr, bitMask, ct)
                                        }</span>
                                        <span class="cov8" title="1">bitMask &lt;&lt;= 1</span>
                                }
                                <span class="cov8" title="1">for _, ct := range head.ToSlice() </span><span class="cov8" title="1">{
                                        setCatSetMask(csr, -bitMask, ct)
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return &amp;result</span>
}

func (fb *FilterBuilder) inlineOrSet(
        orSet immutable.Set[types.Category],
        catSetFreq *hashmap.Map[types.Category, uint]) []types.Category <span class="cov8" title="1">{
        var result []types.Category
        orSet.Each(func(cat types.Category) </span><span class="cov8" title="1">{
                newS := []types.Category{cat}
                if cat &lt; 0 </span><span class="cov8" title="1">{
                        // E.g. AND(OR(-1, 2))
                        // -1 == AND(OR(1))
                        // -1's freq == 1
                        // Replace the AndOrSet with AND(OR(1, 2))
                        catCsr := fb.CatFilterSets[-cat-1]
                        andOrSet := catCsr.CatFilterSet.AndSet
                        if andOrSet.Size() == 1 </span><span class="cov8" title="1">{
                                freq, _ := catSetFreq.Get(cat)
                                inlineOrSet := andOrSet.ToSlice()[0]
                                //if inlineOrSet.Size() &lt; 3 || freq == 1 {
                                if freq == 1 </span><span class="cov8" title="1">{
                                        newS = fb.inlineOrSet(inlineOrSet, catSetFreq)
                                        fb.metrics.OrSetsInlined++
                                }</span>
                        }
                }
                <span class="cov8" title="1">result = append(result, newS...)</span>
        })
        <span class="cov8" title="1">return result</span>
}

func (fb *FilterBuilder) inlineAndOrSet(
        andOrSet types.AndOrSet,
        catSetFreq *hashmap.Map[types.Category, uint]) []immutable.Set[types.Category] <span class="cov8" title="1">{
        var result []immutable.Set[types.Category]
        andOrSet.Each(func(s immutable.Set[types.Category]) </span><span class="cov8" title="1">{
                newS := []immutable.Set[types.Category]{s}
                if s.Size() == 1 </span><span class="cov8" title="1">{
                        cat := s.ToSlice()[0]
                        if cat &lt; 0 </span><span class="cov8" title="1">{
                                // E.g. AND(OR(-1), OR(-2))
                                // -1 == AND(OR(1), OR(2))
                                // -1's freq == 1
                                // Replace the AndOrSet with AND(OR(1), OR(2), OR(-2))
                                catCsr := fb.CatFilterSets[-cat-1]
                                // Make sure that the inlined set immutable.not referenced in a rule.
                                // This can happen when rule condition immutable.included as AND predicate in another rule condition.
                                if len(catCsr.RuleSet) == 0 </span><span class="cov8" title="1">{
                                        freq, ok := catSetFreq.Get(cat)
                                        if ok &amp;&amp; freq == 1 </span><span class="cov0" title="0">{
                                                newS = fb.inlineAndOrSet(catCsr.CatFilterSet.AndSet, catSetFreq)
                                                fb.unregisterFilterSet(catCsr.CatFilterSet.AndSet)
                                                fb.metrics.AndOrSetsInlined++
                                        }</span>
                                }
                        }
                }
                <span class="cov8" title="1">result = append(result, newS...)</span>
        })
        <span class="cov8" title="1">return result</span>
}

func BuildFilterTables(repo *condition.RuleRepo, options *Options) FilterTables <span class="cov8" title="1">{
        fb := NewFilterBuilder(repo, options)
        if fb.options.OrOptimizationFreqThreshold &gt; 0 || fb.options.AndOptimizationFreqThreshold &gt; 0 </span><span class="cov8" title="1">{
                fb.optimize()
        }</span>
        <span class="cov8" title="1">return fb.buildFilterTables()</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package cateng

import (
        "fmt"
        "github.com/atlasgurus/rulestone/condition"
        "github.com/atlasgurus/rulestone/types"
)

type Metrics struct {
        NumBitMaskChecks    uint64
        NumMaskArrayLookups uint64
        NumBitMaskMatches   uint64
        Comment             string
        NumMismatches       uint
}

type CategoryEngine struct {
        ruleRepo     *condition.RuleRepo
        FilterTables FilterTables
        Metrics      Metrics
}

func NewCategoryEngine(repo *condition.RuleRepo, options *Options) *CategoryEngine <span class="cov8" title="1">{
        var result CategoryEngine

        result.ruleRepo = repo
        result.FilterTables = BuildFilterTables(repo, options)
        if options == nil </span><span class="cov8" title="1">{
                result.Metrics.Comment = "non optimized"
        }</span> else<span class="cov8" title="1"> {
                result.Metrics.Comment = "optimized"
        }</span>
        <span class="cov8" title="1">return &amp;result</span>
}

func applyCatSetMasks(csmList []*CatSetMask, matchMaskArray []types.Mask, result *[]condition.RuleIdType, f *CategoryEngine) <span class="cov8" title="1">{
        for _, csm := range csmList </span><span class="cov8" title="1">{
                v := matchMaskArray[csm.Index1-1]
                f.Metrics.NumMaskArrayLookups++
                if v != -1 </span><span class="cov8" title="1">{
                        newV := v | csm.Mask
                        matchMaskArray[csm.Index1-1] = newV
                        f.Metrics.NumBitMaskChecks++
                        if newV == -1 </span><span class="cov8" title="1">{
                                // We got a match.
                                catSetFilter := f.FilterTables.CatSetFilters[csm.Index1-1]

                                f.Metrics.NumBitMaskMatches++

                                // Process the synthetic categories from the set.
                                if len(catSetFilter.CatSetMasks) &gt; 0 </span><span class="cov8" title="1">{
                                        applyCatSetMasks(catSetFilter.CatSetMasks, matchMaskArray, result, f)
                                }</span>
                                <span class="cov8" title="1">for _, cfr := range catSetFilter.RuleSet </span><span class="cov8" title="1">{
                                        *result = append(*result, cfr.RuleId)
                                }</span>
                        }
                }
        }
}

func (f *CategoryEngine) MatchEvent(cats []types.Category) []condition.RuleIdType <span class="cov8" title="1">{
        matchMaskArray := make([]types.Mask, len(f.FilterTables.NegCats)+len(f.FilterTables.CatSetFilters))
        result := make([]condition.RuleIdType, 0, 100)

        defaultCatMap := make([]bool, len(f.FilterTables.DefaultCategories))

        catToCatSetMask := f.FilterTables.CatToCatSetMask
        for _, cat := range cats </span><span class="cov8" title="1">{
                if i, ok := f.FilterTables.DefaultCategories[cat]; ok </span><span class="cov8" title="1">{
                        // The condition evaluated to false for the category with the default value of true.
                        // Take note of that to avoid including this category in the list later in this function.
                        defaultCatMap[i] = true
                }</span>
                <span class="cov8" title="1">csml := catToCatSetMask.Get(cat)
                if csml != nil </span><span class="cov8" title="1">{
                        applyCatSetMasks(csml, matchMaskArray, &amp;result, f)
                }</span>
        }

        // Now process default categories
        <span class="cov8" title="1">for i, cat := range f.FilterTables.DefaultCatList </span><span class="cov8" title="1">{
                if !defaultCatMap[i] </span><span class="cov8" title="1">{
                        negCat, found := f.FilterTables.NegCats[cat]
                        if !found </span><span class="cov0" title="0">{
                                panic("negCat must exist for this")</span>
                        }
                        <span class="cov8" title="1">csml := catToCatSetMask.Get(negCat)
                        if csml != nil </span><span class="cov8" title="1">{
                                applyCatSetMasks(csml, matchMaskArray, &amp;result, f)
                        }</span>
                }
        }
        <span class="cov8" title="1">return result</span>
}

func (f *CategoryEngine) PrintMetrics() <span class="cov0" title="0">{
        fmt.Printf("%s NumMaskArrayLookups: %d\n", f.Metrics.Comment, f.Metrics.NumMaskArrayLookups)
        fmt.Printf("%s NumBitMaskChecks:    %d\n", f.Metrics.Comment, f.Metrics.NumBitMaskChecks)
        fmt.Printf("%s NumBitMaskMatches:   %d\n", f.Metrics.Comment, f.Metrics.NumBitMaskMatches)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package condition

import (
        "fmt"
        "github.com/araddon/dateparse"
        "github.com/atlasgurus/rulestone/immutable"
        "github.com/atlasgurus/rulestone/objectmap"
        "github.com/atlasgurus/rulestone/types"
        "reflect"
        "strconv"
        "time"
)

type CondKind int8

const (
        AndCondKind      CondKind = 1
        OrCondKind                = 2
        NotCondKind               = 3
        CategoryCondKind          = 4
        CompareCondKind           = 5
        ExprCondKind              = 6
        ErrorCondKind             = 7
)

type Condition interface {
        immutable.SetElement
        GetOperands() []Condition
        GetKind() CondKind
}

type AndCond struct {
        Operands []Condition
        Hash     uint64
}

func FindFirstError(cond []Condition) *Condition <span class="cov8" title="1">{
        return types.FindFirstInSlice(cond, func(c Condition) bool </span><span class="cov8" title="1">{
                return c.GetKind() == ErrorCondKind
        }</span>)
}

func FirstError(cond []Condition) Condition <span class="cov8" title="1">{
        result := FindFirstError(cond)
        if result == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov0" title="0">return *result</span>
}

func NewAndCond(cond ...Condition) Condition <span class="cov8" title="1">{
        err := FirstError(cond)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return &amp;AndCond{Operands: cond, Hash: computeCondHash(AndCondKind, cond)}</span>
}

func computeCondHash(kind CondKind, conditions []Condition) uint64 <span class="cov8" title="1">{
        return immutable.HashInt(append([]uint64{uint64(kind)},
                types.MapSlice(conditions, func(c Condition) uint64 </span><span class="cov8" title="1">{
                        return c.GetHash()
                }</span>)...))
}

func (c *AndCond) GetOperands() []Condition <span class="cov8" title="1">{
        return c.Operands
}</span>

func (c *AndCond) GetKind() CondKind <span class="cov8" title="1">{
        return AndCondKind
}</span>

func (c *AndCond) GetHash() uint64 <span class="cov8" title="1">{
        return c.Hash
}</span>

func (c *AndCond) Equals(v immutable.SetElement) bool <span class="cov8" title="1">{
        return c.GetHash() == v.(Condition).GetHash()
}</span>

type OrCond struct {
        Operands []Condition
        Hash     uint64
}

func NewOrCond(cond ...Condition) Condition <span class="cov8" title="1">{
        err := FirstError(cond)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return &amp;OrCond{Operands: cond, Hash: computeCondHash(OrCondKind, cond)}</span>
}

func (c *OrCond) GetOperands() []Condition <span class="cov8" title="1">{
        return c.Operands
}</span>

func (c *OrCond) GetKind() CondKind <span class="cov8" title="1">{
        return OrCondKind
}</span>

func (c *OrCond) GetHash() uint64 <span class="cov8" title="1">{
        return c.Hash
}</span>

func (c *OrCond) Equals(v immutable.SetElement) bool <span class="cov0" title="0">{
        return c.GetHash() == v.(Condition).GetHash()
}</span>

type NotCond struct {
        Operand Condition
        Hash    uint64
}

func NewNotCond(cond Condition) Condition <span class="cov8" title="1">{
        if cond.GetKind() == ErrorCondKind </span><span class="cov0" title="0">{
                return cond
        }</span>
        <span class="cov8" title="1">return &amp;NotCond{Operand: cond, Hash: computeCondHash(NotCondKind, []Condition{cond})}</span>
}

func (c *NotCond) GetOperands() []Condition <span class="cov8" title="1">{
        return []Condition{c.Operand}
}</span>

func (c *NotCond) GetKind() CondKind <span class="cov8" title="1">{
        return NotCondKind
}</span>

func (c *NotCond) GetHash() uint64 <span class="cov8" title="1">{
        return c.Hash
}</span>

func (c *NotCond) Equals(v immutable.SetElement) bool <span class="cov0" title="0">{
        return c.GetHash() == v.(Condition).GetHash()
}</span>

type CategoryCond struct {
        Cat  types.Category
        Hash uint64
}

func NewCategoryCond(cat types.Category) Condition <span class="cov8" title="1">{
        return &amp;CategoryCond{Cat: cat, Hash: immutable.HashInt([]int32{CategoryCondKind, int32(cat)})}
}</span>

func (c *CategoryCond) GetOperands() []Condition <span class="cov0" title="0">{
        panic("GetOperands is not defined for Category condition")</span>
}

func (c *CategoryCond) GetKind() CondKind <span class="cov8" title="1">{
        return CategoryCondKind
}</span>

func (c *CategoryCond) GetHash() uint64 <span class="cov8" title="1">{
        return c.Hash
}</span>

func (c *CategoryCond) Equals(v immutable.SetElement) bool <span class="cov0" title="0">{
        return c.GetHash() == v.(Condition).GetHash()
}</span>

type ErrorCondition struct {
        Err  error
        Hash uint64
}

func NewErrorCondition(val error) Condition <span class="cov0" title="0">{
        return &amp;ErrorCondition{
                Err:  val,
                Hash: immutable.HashInt([]uint64{uint64(ErrorCondKind), immutable.HashString(val.Error())})}
}</span>

func (c *ErrorCondition) GetHash() uint64 <span class="cov0" title="0">{
        return c.Hash
}</span>

func (c *ErrorCondition) Equals(v immutable.SetElement) bool <span class="cov0" title="0">{
        return c.GetHash() == v.(Condition).GetHash()
}</span>

func (c *ErrorCondition) GetOperands() []Condition <span class="cov0" title="0">{
        panic("GetOperands is not defined for ErrorCondition condition")</span>
}

func (c *ErrorCondition) GetKind() CondKind <span class="cov0" title="0">{
        return ErrorCondKind
}</span>

type ExprCondition struct {
        Expr string
        Hash uint64
}

func NewExprCondition(val string) Condition <span class="cov8" title="1">{
        return &amp;ExprCondition{
                Expr: val,
                Hash: immutable.HashInt([]uint64{uint64(ExprCondKind), immutable.HashString(val)})}
}</span>

func (c *ExprCondition) GetHash() uint64 <span class="cov8" title="1">{
        return c.Hash
}</span>

func (c *ExprCondition) Equals(v immutable.SetElement) bool <span class="cov0" title="0">{
        return c.GetHash() == v.(Condition).GetHash()
}</span>

func (c *ExprCondition) GetOperands() []Condition <span class="cov0" title="0">{
        panic("GetOperands is not defined for ExprCondition condition")</span>
}

func (c *ExprCondition) GetKind() CondKind <span class="cov8" title="1">{
        return ExprCondKind
}</span>

type CompareOp uint8

const (
        CompareEqualOp          CompareOp = 1
        CompareNotEqualOp                 = 2
        CompareGreaterOp                  = 3
        CompareGreaterOrEqualOp           = 4
        CompareLessOp                     = 5
        CompareLessOrEqualOp              = 6
        CompareContainsOp                 = 7
        CompareInvalidOp                  = 99
)

type OperandKind uint8

const (
        StringOperandKind     OperandKind = 1
        IntOperandKind                    = 2
        FloatOperandKind                  = 3
        BooleanOperandKind                = 4
        TimeOperandKind                   = 5
        AttributeOperandKind              = 6
        ExpressionOperandKind             = 7
        AddressOperandKind                = 8
        SelOperandKind                    = 9
        IndexOperandKind                  = 10
        NullOperandKind                   = 11
        ListOperandKind                   = 12
        ErrorOperandKind                  = 13
)

type EvalOperandFunc func(event *objectmap.ObjectAttributeMap, frames []interface{}) Operand
type OperandEvaluator interface {
        Evaluate(event *objectmap.ObjectAttributeMap, frames []interface{}) Operand
}

type Operand interface {
        immutable.SetElement
        IsConst() bool
        GetKind() OperandKind
        Greater(o Operand) bool
        Convert(to OperandKind) Operand
        OperandEvaluator
}

type ListOperand struct {
        List []Operand
}

// NewListOperand do not compute hash on creation.  We use ListOperand at runtime and need it to be fast
func NewListOperand(list []Operand) *ListOperand <span class="cov8" title="1">{
        return &amp;ListOperand{List: list}
}</span>

func (v *ListOperand) Convert(to OperandKind) Operand <span class="cov0" title="0">{
        panic(fmt.Errorf("unexpected conversion of ListOperand"))</span>
}

func (v *ListOperand) IsConst() bool <span class="cov0" title="0">{
        return false
}</span>

func (v *ListOperand) GetKind() OperandKind <span class="cov0" title="0">{
        return ListOperandKind
}</span>

func (v *ListOperand) GetHash() uint64 <span class="cov0" title="0">{
        return immutable.HashInt(
                []uint64{
                        uint64(ListOperandKind),
                        immutable.HashInt(types.MapSlice(v.List, func(o Operand) uint64 </span><span class="cov0" title="0">{ return o.GetHash() }</span>))})
}

func (v *ListOperand) Equals(o immutable.SetElement) bool <span class="cov0" title="0">{
        return v.GetHash() == o.GetHash()
}</span>

func (v *ListOperand) Greater(o Operand) bool <span class="cov0" title="0">{
        panic(fmt.Errorf("greater is not supported for ListOperand"))</span>
}

func (v *ListOperand) Evaluate(event *objectmap.ObjectAttributeMap, frames []interface{}) Operand <span class="cov0" title="0">{
        return v
}</span>

type ExprOperand struct {
        Func EvalOperandFunc
        Args []Operand
        Hash uint64
}

func NewExprOperand(f EvalOperandFunc, args ...Operand) *ExprOperand <span class="cov8" title="1">{
        return &amp;ExprOperand{
                Func: f,
                Args: args,
                Hash: immutable.HashInt(
                        []uint64{
                                uint64(ExpressionOperandKind),
                                uint64(reflect.ValueOf(f).Pointer()),
                                immutable.HashInt(types.MapSlice(args, func(o Operand) uint64 </span><span class="cov8" title="1">{ return o.GetHash() }</span>))})}
}

func (v *ExprOperand) Convert(to OperandKind) Operand <span class="cov0" title="0">{
        panic(fmt.Errorf("unexpected conversion of ExprOperand"))</span>
}

func (v *ExprOperand) IsConst() bool <span class="cov8" title="1">{
        return false
}</span>

func (v *ExprOperand) GetKind() OperandKind <span class="cov8" title="1">{
        return ExpressionOperandKind
}</span>

func (v *ExprOperand) GetHash() uint64 <span class="cov8" title="1">{
        return v.Hash
}</span>

func (v *ExprOperand) Equals(o immutable.SetElement) bool <span class="cov8" title="1">{
        return v.GetHash() == o.GetHash()
}</span>

func (v *ExprOperand) Greater(o Operand) bool <span class="cov0" title="0">{
        panic(fmt.Errorf("greater is not supported for ExprOperand"))</span>
}

func (v *ExprOperand) Evaluate(event *objectmap.ObjectAttributeMap, frames []interface{}) Operand <span class="cov8" title="1">{
        return v.Func(event, frames)
}</span>

type IntOperand int64

func NewIntOperand(val int64) Operand <span class="cov8" title="1">{
        return IntOperand(val)
}</span>

func (v IntOperand) Convert(to OperandKind) Operand <span class="cov8" title="1">{
        switch to </span>{
        case TimeOperandKind:<span class="cov0" title="0">
                return NewTimeOperand(time.Unix(0, int64(v)))</span>
        case IntOperandKind:<span class="cov0" title="0">
                return v</span>
        case FloatOperandKind:<span class="cov8" title="1">
                return NewFloatOperand(float64(v))</span>
        case BooleanOperandKind:<span class="cov0" title="0">
                return NewBooleanOperand(v != 0)</span>
        case StringOperandKind:<span class="cov0" title="0">
                return NewStringOperand(strconv.Itoa(int(v)))</span>
        case NullOperandKind:<span class="cov0" title="0">
                return NewNullOperand(nil)</span>
        default:<span class="cov0" title="0">
                panic(fmt.Errorf("Unexpected conversion to %d ", to))</span>
        }
}

func (v IntOperand) IsConst() bool <span class="cov0" title="0">{
        return true
}</span>

func (v IntOperand) GetKind() OperandKind <span class="cov8" title="1">{
        return IntOperandKind
}</span>

func (v IntOperand) GetHash() uint64 <span class="cov8" title="1">{
        return uint64(v)
}</span>

func (v IntOperand) Equals(o immutable.SetElement) bool <span class="cov8" title="1">{
        return o.(Operand).GetKind() == IntOperandKind &amp;&amp; v == o.(IntOperand)
}</span>

func (v IntOperand) Greater(o Operand) bool <span class="cov0" title="0">{
        return v &gt; o.(IntOperand)
}</span>

func (v IntOperand) Evaluate(event *objectmap.ObjectAttributeMap, frames []interface{}) Operand <span class="cov0" title="0">{
        return v
}</span>

type FloatOperand float64

func (v FloatOperand) Convert(to OperandKind) Operand <span class="cov8" title="1">{
        switch to </span>{
        case TimeOperandKind:<span class="cov0" title="0">
                return NewTimeOperand(time.Unix(0, int64(v)))</span>
        case IntOperandKind:<span class="cov8" title="1">
                return NewIntOperand(int64(v))</span>
        case FloatOperandKind:<span class="cov8" title="1">
                return v</span>
        case BooleanOperandKind:<span class="cov0" title="0">
                return NewBooleanOperand(v != 0)</span>
        case StringOperandKind:<span class="cov0" title="0">
                return NewStringOperand(strconv.FormatFloat(float64(v), 'g', -1, 64))</span>
        case NullOperandKind:<span class="cov0" title="0">
                return NewNullOperand(nil)</span>
        default:<span class="cov0" title="0">
                panic(fmt.Errorf("Unexpected conversion to %d ", to))</span>
        }
}

func NewFloatOperand(val float64) Operand <span class="cov8" title="1">{
        var result Operand = FloatOperand(val)
        return result
}</span>

func (v FloatOperand) IsConst() bool <span class="cov8" title="1">{
        return true
}</span>

func (v FloatOperand) GetKind() OperandKind <span class="cov8" title="1">{
        return FloatOperandKind
}</span>

func (v FloatOperand) GetHash() uint64 <span class="cov8" title="1">{
        return uint64(v)
}</span>

func (v FloatOperand) Equals(o immutable.SetElement) bool <span class="cov8" title="1">{
        return o.(Operand).GetKind() == FloatOperandKind &amp;&amp; v == o.(FloatOperand)
}</span>

func (v FloatOperand) Greater(o Operand) bool <span class="cov8" title="1">{
        return v &gt; o.(FloatOperand)
}</span>

func (v FloatOperand) Evaluate(event *objectmap.ObjectAttributeMap, frames []interface{}) Operand <span class="cov8" title="1">{
        return v
}</span>

type StringOperand string

func NewStringOperand(val string) Operand <span class="cov8" title="1">{
        return StringOperand(val)
}</span>

func (v StringOperand) Convert(to OperandKind) Operand <span class="cov8" title="1">{
        switch to </span>{
        case TimeOperandKind:<span class="cov8" title="1">
                t, err := dateparse.ParseAny(string(v))
                if err != nil </span><span class="cov0" title="0">{
                        return NewErrorOperand(err)
                }</span>
                <span class="cov8" title="1">return NewTimeOperand(t)</span>
        case IntOperandKind:<span class="cov0" title="0">
                i, err := strconv.ParseInt(string(v), 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return NewErrorOperand(fmt.Errorf("Err %s converting %s to IntOperand", err.Error(), string(v)))
                }</span>
                <span class="cov0" title="0">return NewIntOperand(i)</span>
        case FloatOperandKind:<span class="cov0" title="0">
                f, err := strconv.ParseFloat(string(v), 64)
                if err != nil </span><span class="cov0" title="0">{
                        return NewErrorOperand(fmt.Errorf("Err %s converting %s to IntOperand", err.Error(), string(v)))
                }</span>
                <span class="cov0" title="0">return NewFloatOperand(f)</span>
        case BooleanOperandKind:<span class="cov0" title="0">
                return NewBooleanOperand(v != "true")</span>
        case StringOperandKind:<span class="cov8" title="1">
                return v</span>
        case NullOperandKind:<span class="cov8" title="1">
                return NewNullOperand(nil)</span>
        default:<span class="cov0" title="0">
                panic(fmt.Errorf("unexpected conversion to %d ", to))</span>
        }
}

func (v StringOperand) IsConst() bool <span class="cov8" title="1">{
        return true
}</span>

func (v StringOperand) GetKind() OperandKind <span class="cov8" title="1">{
        return StringOperandKind
}</span>

func (v StringOperand) GetHash() uint64 <span class="cov8" title="1">{
        return immutable.HashString(string(v))
}</span>

func (v StringOperand) Equals(o immutable.SetElement) bool <span class="cov8" title="1">{
        return o.(Operand).GetKind() == StringOperandKind &amp;&amp; v == o.(StringOperand)
}</span>

func (v StringOperand) Greater(o Operand) bool <span class="cov0" title="0">{
        return v &gt; o.(StringOperand)
}</span>

func (v StringOperand) Evaluate(event *objectmap.ObjectAttributeMap, frames []interface{}) Operand <span class="cov8" title="1">{
        return v
}</span>

type TimeOperand time.Time

func NewTimeOperand(val time.Time) Operand <span class="cov8" title="1">{
        return TimeOperand(val)
}</span>

func (v TimeOperand) Convert(to OperandKind) Operand <span class="cov0" title="0">{
        switch to </span>{
        case IntOperandKind:<span class="cov0" title="0">
                return NewIntOperand(time.Time(v).UnixNano())</span>
        case FloatOperandKind:<span class="cov0" title="0">
                return NewFloatOperand(float64(time.Time(v).UnixNano()))</span>
        case BooleanOperandKind:<span class="cov0" title="0">
                panic(fmt.Errorf("unexpected conversion to %d ", to))</span>
        case TimeOperandKind:<span class="cov0" title="0">
                return v</span>
        case StringOperandKind:<span class="cov0" title="0">
                return NewStringOperand(time.Time(v).Format(time.RFC3339Nano))</span>
        case NullOperandKind:<span class="cov0" title="0">
                return NewNullOperand(nil)</span>
        default:<span class="cov0" title="0">
                panic(fmt.Errorf("unexpected conversion to %d ", to))</span>
        }
}

func (v TimeOperand) IsConst() bool <span class="cov8" title="1">{
        return true
}</span>

func (v TimeOperand) GetKind() OperandKind <span class="cov8" title="1">{
        return TimeOperandKind
}</span>

func (v TimeOperand) GetHash() uint64 <span class="cov8" title="1">{
        return immutable.HashInt(time.Time(v).UnixNano())
}</span>

func (v TimeOperand) Equals(o immutable.SetElement) bool <span class="cov8" title="1">{
        return o.(Operand).GetKind() == TimeOperandKind &amp;&amp; time.Time(v).Equal(time.Time(o.(TimeOperand)))
}</span>

func (v TimeOperand) Greater(o Operand) bool <span class="cov8" title="1">{
        return time.Time(v).After(time.Time(o.(TimeOperand)))
}</span>

func (v TimeOperand) Evaluate(event *objectmap.ObjectAttributeMap, frames []interface{}) Operand <span class="cov8" title="1">{
        return v
}</span>

type BooleanOperand bool

var IntConst1 IntOperand = 1
var IntConst0 IntOperand = 0

var FloatConst1 FloatOperand = 1
var FloatConst0 FloatOperand = 0

func (v BooleanOperand) Convert(to OperandKind) Operand <span class="cov8" title="1">{
        switch to </span>{
        case IntOperandKind:<span class="cov0" title="0">
                if v </span><span class="cov0" title="0">{
                        return IntConst1
                }</span> else<span class="cov0" title="0"> {
                        return IntConst0
                }</span>
        case FloatOperandKind:<span class="cov0" title="0">
                if v </span><span class="cov0" title="0">{
                        return FloatConst1
                }</span> else<span class="cov0" title="0"> {
                        return FloatConst0
                }</span>
        case BooleanOperandKind:<span class="cov8" title="1">
                return v</span>
        case StringOperandKind:<span class="cov0" title="0">
                return NewStringOperand(strconv.FormatBool(bool(v)))</span>
        case NullOperandKind:<span class="cov0" title="0">
                return NewNullOperand(nil)</span>
        default:<span class="cov0" title="0">
                panic(fmt.Errorf("unexpected conversion to %d ", to))</span>
        }
}

var trueBooleanOperand BooleanOperand = true
var falseBooleanOperand BooleanOperand = false

func NewBooleanOperand(val bool) BooleanOperand <span class="cov8" title="1">{
        if val </span><span class="cov8" title="1">{
                return trueBooleanOperand
        }</span> else<span class="cov8" title="1"> {
                return falseBooleanOperand
        }</span>
}

func (v BooleanOperand) IsConst() bool <span class="cov8" title="1">{
        return true
}</span>

func (v BooleanOperand) GetKind() OperandKind <span class="cov8" title="1">{
        return BooleanOperandKind
}</span>

func (v BooleanOperand) GetHash() uint64 <span class="cov8" title="1">{
        if v </span><span class="cov8" title="1">{
                return 1
        }</span> else<span class="cov8" title="1"> {
                return 0
        }</span>
}

func (v BooleanOperand) Equals(o immutable.SetElement) bool <span class="cov8" title="1">{
        return v == o.(BooleanOperand)
}</span>

func (v BooleanOperand) Greater(o Operand) bool <span class="cov0" title="0">{
        return bool(v &amp;&amp; !o.(BooleanOperand))
}</span>

func (v BooleanOperand) Evaluate(event *objectmap.ObjectAttributeMap, frames []interface{}) Operand <span class="cov0" title="0">{
        return v
}</span>

type AttributeOperand struct {
        AttributePath string
}

func (v *AttributeOperand) Convert(to OperandKind) Operand <span class="cov0" title="0">{
        panic("Conversion of AttributeOperand is not supported")</span>
}

func NewAttributeOperand(attributePath string) *AttributeOperand <span class="cov0" title="0">{
        return &amp;AttributeOperand{AttributePath: attributePath}
}</span>

func (v *AttributeOperand) Greater(o Operand) bool <span class="cov0" title="0">{
        panic("Comparison of AttributeOperand not supported")</span>
}

func (v *AttributeOperand) IsConst() bool <span class="cov0" title="0">{
        return false
}</span>

func (v *AttributeOperand) GetKind() OperandKind <span class="cov0" title="0">{
        return AttributeOperandKind
}</span>

func (v *AttributeOperand) GetHash() uint64 <span class="cov0" title="0">{
        return immutable.HashString(v.AttributePath)
}</span>

func (v *AttributeOperand) Equals(o immutable.SetElement) bool <span class="cov0" title="0">{
        return o.(Operand).GetKind() == AttributeOperandKind &amp;&amp;
                v.AttributePath == o.(*AttributeOperand).AttributePath
}</span>

func (v *AttributeOperand) Evaluate(event *objectmap.ObjectAttributeMap, frames []interface{}) Operand <span class="cov0" title="0">{
        panic("implement me")</span>
}

type AddressOperand struct {
        Address        []int
        FullAddress    []int
        ParameterIndex int
        ExprOperand    *ExprOperand
        Hash           uint64
}

func NewAddressOperand(address []int, fullAddress []int, parameterIndex int, exprOperand *ExprOperand) *AddressOperand <span class="cov8" title="1">{
        return &amp;AddressOperand{
                Address:        address,
                FullAddress:    fullAddress,
                ParameterIndex: parameterIndex,
                ExprOperand:    exprOperand,
                Hash: immutable.HashInt(
                        []uint64{uint64(AddressOperandKind),
                                immutable.HashIntArray(address),
                                immutable.HashIntArray(fullAddress),
                                uint64(parameterIndex),
                                uint64(reflect.ValueOf(exprOperand).Pointer())}),
        }
}</span>

func (v *AddressOperand) Convert(to OperandKind) Operand <span class="cov0" title="0">{
        panic("Conversion of AddressOperand is not supported")</span>
}

func (v *AddressOperand) Greater(o Operand) bool <span class="cov0" title="0">{
        panic("Comparison of AddressOperand not supported")</span>
}

func (v *AddressOperand) IsConst() bool <span class="cov8" title="1">{
        return false
}</span>

func (v *AddressOperand) GetKind() OperandKind <span class="cov8" title="1">{
        return AddressOperandKind
}</span>

func (v *AddressOperand) GetHash() uint64 <span class="cov8" title="1">{
        return v.Hash
}</span>

func (v *AddressOperand) Equals(o immutable.SetElement) bool <span class="cov8" title="1">{
        return v.Hash == o.GetHash()
}</span>

func (v *AddressOperand) Evaluate(event *objectmap.ObjectAttributeMap, frames []interface{}) Operand <span class="cov8" title="1">{
        if v.ExprOperand == nil </span><span class="cov8" title="1">{
                return v
        }</span> else<span class="cov8" title="1"> {
                return v.ExprOperand.Evaluate(event, frames)
        }</span>
}

type SelOperand struct {
        Base     Operand
        Selector string
        Hash     uint64
}

func NewSelOperand(base Operand, selector string) *SelOperand <span class="cov8" title="1">{
        baseHash := uint64(0)
        if base != nil </span><span class="cov8" title="1">{
                baseHash = base.GetHash()
        }</span>
        <span class="cov8" title="1">return &amp;SelOperand{Base: base, Selector: selector,
                Hash: immutable.HashInt([]uint64{uint64(SelOperandKind), baseHash, immutable.HashString(selector)})}</span>
}

func (v *SelOperand) Convert(to OperandKind) Operand <span class="cov0" title="0">{
        panic("Conversion of SelOperand is not supported")</span>
}

func (v *SelOperand) Greater(o Operand) bool <span class="cov0" title="0">{
        panic("Comparison of SelOperand not supported")</span>
}

func (v *SelOperand) IsConst() bool <span class="cov0" title="0">{
        return false
}</span>

func (v *SelOperand) GetKind() OperandKind <span class="cov8" title="1">{
        return SelOperandKind
}</span>

func (v *SelOperand) GetHash() uint64 <span class="cov8" title="1">{
        return v.Hash
}</span>

func (v *SelOperand) Equals(o immutable.SetElement) bool <span class="cov8" title="1">{
        return v.Hash == o.GetHash()
        /*
                return o.GetKind() == AddressOperandKind &amp;&amp;
                        // Path is not the best proxy attribute for compare, but we may not even use this, so do not bother for now.
                        v.Base.Equals(o.(*AddressOperand).Base) &amp;&amp;
                        v.Selector == o.(*AddressOperand).Selector &amp;&amp;
                        v.IndexExpr == o.(*AddressOperand).IndexExpr
        */
}</span>

func (v *SelOperand) Evaluate(event *objectmap.ObjectAttributeMap, frames []interface{}) Operand <span class="cov0" title="0">{
        panic("implement me")</span>
}

type IndexOperand struct {
        Base      Operand
        IndexExpr Operand
        Hash      uint64
}

func NewIndexOperand(base Operand, indexExpr Operand) *IndexOperand <span class="cov8" title="1">{
        return &amp;IndexOperand{Base: base, IndexExpr: indexExpr,
                Hash: immutable.HashInt([]uint64{uint64(IndexOperandKind), base.GetHash(), indexExpr.GetHash()})}
}</span>

func (v *IndexOperand) Convert(to OperandKind) Operand <span class="cov0" title="0">{
        panic("Conversion of IndexOperand is not supported")</span>
}

func (v *IndexOperand) Greater(o Operand) bool <span class="cov0" title="0">{
        panic("Comparison of IndexOperand not supported")</span>
}

func (v *IndexOperand) IsConst() bool <span class="cov0" title="0">{
        return false
}</span>

func (v *IndexOperand) GetKind() OperandKind <span class="cov8" title="1">{
        return IndexOperandKind
}</span>

func (v *IndexOperand) GetHash() uint64 <span class="cov8" title="1">{
        return v.Hash
}</span>

func (v *IndexOperand) Equals(o immutable.SetElement) bool <span class="cov0" title="0">{
        return v.Hash == o.GetHash()
        /*
                return o.GetKind() == AddressOperandKind &amp;&amp;
                        // Path is not the best proxy attribute for compare, but we may not even use this, so do not bother for now.
                        v.Base.Equals(o.(*AddressOperand).Base) &amp;&amp;
                        v.Selector == o.(*AddressOperand).Selector &amp;&amp;
                        v.IndexExpr == o.(*AddressOperand).IndexExpr
        */
}</span>

func (v *IndexOperand) Evaluate(event *objectmap.ObjectAttributeMap, frames []interface{}) Operand <span class="cov0" title="0">{
        panic("implement me")</span>
}

type ErrorOperand struct {
        Err error
}

func (v ErrorOperand) Error() string <span class="cov0" title="0">{
        return v.Err.Error()
}</span>

func (v ErrorOperand) Convert(to OperandKind) Operand <span class="cov0" title="0">{
        // Can't convert Err to anything.  Return Err
        // Could capture a nested Err here
        return v
}</span>

func NewErrorOperand(val error) Operand <span class="cov8" title="1">{
        return ErrorOperand{val}
}</span>

func (v ErrorOperand) IsConst() bool <span class="cov0" title="0">{
        return true
}</span>

func (v ErrorOperand) GetKind() OperandKind <span class="cov8" title="1">{
        return ErrorOperandKind
}</span>

func (v ErrorOperand) GetHash() uint64 <span class="cov0" title="0">{
        return immutable.HashString(v.Error())
}</span>

func (v ErrorOperand) Equals(o immutable.SetElement) bool <span class="cov0" title="0">{
        return false
}</span>

func (v ErrorOperand) Greater(o Operand) bool <span class="cov0" title="0">{
        return false
}</span>

func (v ErrorOperand) Evaluate(event *objectmap.ObjectAttributeMap, frames []interface{}) Operand <span class="cov0" title="0">{
        return v
}</span>

type NullOperand struct {
        address *AddressOperand
}

func (v NullOperand) Convert(to OperandKind) Operand <span class="cov8" title="1">{
        // Can't convert null to anything.  Return error.
        return NewErrorOperand(fmt.Errorf("invalid conversion of null operand to %d", to))
}</span>

func NewNullOperand(val *AddressOperand) Operand <span class="cov8" title="1">{
        return NullOperand{val}
}</span>

func (v NullOperand) IsConst() bool <span class="cov0" title="0">{
        return true
}</span>

func (v NullOperand) GetKind() OperandKind <span class="cov8" title="1">{
        return NullOperandKind
}</span>

func (v NullOperand) GetHash() uint64 <span class="cov0" title="0">{
        return 0
}</span>

func (v NullOperand) Equals(o immutable.SetElement) bool <span class="cov8" title="1">{
        return false
}</span>

func (v NullOperand) Greater(o Operand) bool <span class="cov0" title="0">{
        return false
}</span>

func (v NullOperand) Evaluate(event *objectmap.ObjectAttributeMap, frames []interface{}) Operand <span class="cov0" title="0">{
        return v
}</span>

type CompareCondition struct {
        CompareOp    CompareOp
        LeftOperand  Operand
        RightOperand Operand
        Hash         uint64
}

func NewCompareCond(op CompareOp, l Operand, r Operand) *CompareCondition <span class="cov8" title="1">{
        return &amp;CompareCondition{
                CompareOp:    op,
                LeftOperand:  l,
                RightOperand: r,
                Hash:         immutable.HashInt([]uint64{l.GetHash(), r.GetHash(), uint64(op)})}
}</span>

func (cond *CompareCondition) GetOperands() []Condition <span class="cov0" title="0">{
        return nil
}</span>

func (cond *CompareCondition) GetKind() CondKind <span class="cov0" title="0">{
        return CompareCondKind
}</span>

func (cond *CompareCondition) GetHash() uint64 <span class="cov8" title="1">{
        return cond.Hash
}</span>

func (cond *CompareCondition) Equals(v immutable.SetElement) bool <span class="cov8" title="1">{
        return cond.Hash == v.GetHash()
}</span>

type ForEach interface {
        GetElement() string
        GetPath() string
        GetCond() Condition
        GetHash() uint64
        Equals(element immutable.SetElement) bool
}

func NewInterfaceOperand(v interface{}, ctx *types.AppContext) Operand <span class="cov8" title="1">{
        switch n := v.(type) </span>{
        case nil:<span class="cov8" title="1">
                return NewNullOperand(nil)</span>
        case int:<span class="cov8" title="1">
                return NewIntOperand(int64(n))</span>
        case int64:<span class="cov0" title="0">
                return NewIntOperand(n)</span>
        case string:<span class="cov8" title="1">
                return NewStringOperand(n)</span>
        case float64:<span class="cov8" title="1">
                return NewFloatOperand(n)</span>
        case bool:<span class="cov8" title="1">
                return NewBooleanOperand(n)</span>
        case map[string]interface{}:<span class="cov0" title="0">
                return NewErrorOperand(ctx.Errorf("scalar operand expected got map: %v", v))</span>
        case []interface{}:<span class="cov0" title="0">
                return NewErrorOperand(ctx.Errorf("scalar operand expected got slice: %v", v))</span>
        default:<span class="cov0" title="0">
                panic("Should not get here")</span>
        }
}

// ReconcileOperands TODO: may need to add reconcile kind, e.g. compare, arithmetic, string, etc.
func ReconcileOperands(x, y Operand) (Operand, Operand) <span class="cov8" title="1">{
        xkind := x.GetKind()
        ykind := y.GetKind()
        if xkind &lt; ykind </span><span class="cov8" title="1">{
                return x.Convert(y.GetKind()), y
        }</span> else<span class="cov8" title="1"> if xkind &gt; ykind </span><span class="cov8" title="1">{
                return x, y.Convert(x.GetKind())
        }</span> else<span class="cov8" title="1"> {
                return x, y
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package condition

import (
        "github.com/atlasgurus/rulestone/immutable"
        "github.com/atlasgurus/rulestone/types"
)

func AndOrSetToCondition(set types.AndOrSet) Condition <span class="cov0" title="0">{
        return NewAndCond(types.MapSlice(
                set.ToSlice(), func(orSet immutable.Set[types.Category]) Condition </span><span class="cov0" title="0">{
                        return NewOrCond(types.MapSlice(
                                orSet.ToSlice(), func(cat types.Category) Condition </span><span class="cov0" title="0">{
                                        return NewCategoryCond(cat)
                                }</span>)...)
                })...)
}

func CategoryArraysToCondition(cats [][]types.Category) Condition <span class="cov0" title="0">{
        return NewAndCond(types.MapSlice(
                cats, func(orSet []types.Category) Condition </span><span class="cov0" title="0">{
                        return NewOrCond(types.MapSlice[types.Category, Condition](
                                orSet, func(cat types.Category) Condition </span><span class="cov0" title="0">{
                                        return NewCategoryCond(cat)
                                }</span>)...)
                })...)
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package condition

import (
        "github.com/atlasgurus/rulestone/types"
        "github.com/zyedidia/generic/hashmap"
)

type Factory struct {
        OperandCache   *hashmap.Map[Operand, Operand]
        ConditionCache *hashmap.Map[Condition, Condition]
}

func NewFactory() *Factory <span class="cov8" title="1">{
        return &amp;Factory{
                OperandCache:   types.NewHashMap[Operand, Operand](),
                ConditionCache: types.NewHashMap[Condition, Condition](),
        }
}</span>

func (factory *Factory) CacheOperand(operand Operand) Operand <span class="cov8" title="1">{
        result, ok := factory.OperandCache.Get(operand)
        if !ok </span><span class="cov8" title="1">{
                factory.OperandCache.Put(operand, operand)
                result = operand
        }</span>
        <span class="cov8" title="1">return result</span>
}

func (factory *Factory) NewIntOperand(val int64) Operand <span class="cov8" title="1">{
        return factory.CacheOperand(NewIntOperand(val))
}</span>

func (factory *Factory) NewFloatOperand(val float64) Operand <span class="cov8" title="1">{
        return factory.CacheOperand(NewFloatOperand(val))
}</span>

func (factory *Factory) NewStringOperand(val string) Operand <span class="cov8" title="1">{
        return factory.CacheOperand(NewStringOperand(val))
}</span>

func (factory *Factory) NewBooleanOperand(val bool) Operand <span class="cov0" title="0">{
        return factory.CacheOperand(NewBooleanOperand(val))
}</span>

func (factory *Factory) NewAttributeOperand(val string) Operand <span class="cov0" title="0">{
        return factory.CacheOperand(NewAttributeOperand(val))
}</span>

func (factory *Factory) NewAddressOperand(address []int, fullAddress []int, parameterIndex int, exprOperand *ExprOperand) Operand <span class="cov8" title="1">{
        if exprOperand == nil </span><span class="cov8" title="1">{
                return factory.CacheOperand(NewAddressOperand(address, fullAddress, parameterIndex, exprOperand))
        }</span> else<span class="cov8" title="1"> {
                return NewAddressOperand(address, fullAddress, parameterIndex, exprOperand)
        }</span>
}

func (factory *Factory) NewSelOperand(base Operand, selector string) Operand <span class="cov8" title="1">{
        return factory.CacheOperand(NewSelOperand(base, selector))
}</span>

func (factory *Factory) NewIndexOperand(base Operand, indexExpr Operand) Operand <span class="cov8" title="1">{
        return factory.CacheOperand(NewIndexOperand(base, indexExpr))
}</span>

func (factory *Factory) NewErrorOperand(val error) Operand <span class="cov0" title="0">{
        return factory.CacheOperand(NewErrorOperand(val))
}</span>

func (factory *Factory) NewExprOperand(f EvalOperandFunc, args ...Operand) *ExprOperand <span class="cov8" title="1">{
        return factory.CacheOperand(NewExprOperand(f, args...)).(*ExprOperand)
}</span>

func (factory *Factory) CacheCondition(cond Condition) Condition <span class="cov8" title="1">{
        result, ok := factory.ConditionCache.Get(cond)
        if !ok </span><span class="cov8" title="1">{
                factory.ConditionCache.Put(cond, cond)
                result = cond
        }</span>
        <span class="cov8" title="1">return result</span>
}

func (factory *Factory) NewCompareCond(op CompareOp, l Operand, r Operand) Condition <span class="cov0" title="0">{
        return factory.CacheCondition(NewCompareCond(op, l, r))
}</span>

func (factory *Factory) NewAndCond(cond ...Condition) Condition <span class="cov8" title="1">{
        return factory.CacheCondition(NewAndCond(cond...))
}</span>

func (factory *Factory) NewOrCond(cond ...Condition) Condition <span class="cov8" title="1">{
        return factory.CacheCondition(NewOrCond(cond...))
}</span>

func (factory *Factory) NewNotCond(cond Condition) Condition <span class="cov0" title="0">{
        return factory.CacheCondition(NewNotCond(cond))
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package condition

import (
        "github.com/atlasgurus/rulestone/types"
)

type RuleIdType uint32

type Rule struct {
        RuleId RuleIdType
        Cond   Condition
}

func NewRule(RuleId RuleIdType, Cond Condition) *Rule <span class="cov8" title="1">{
        return &amp;Rule{RuleId: RuleId, Cond: Cond}
}</span>

type RuleIndexType int32

type RuleRec struct {
        Rule      *Rule
        RuleIndex RuleIndexType
}

type RuleRepo struct {
        Rules []*Rule
}

func NewRuleRepo(rules []*Rule) *RuleRepo <span class="cov0" title="0">{
        return &amp;RuleRepo{Rules: rules}
}</span>

func (repo *RuleRepo) Register(rule *Rule) <span class="cov8" title="1">{
        repo.Rules = append(repo.Rules, rule)
}</span>

func AndOrTablesToRuleRepo(tables [][][]types.Category) *RuleRepo <span class="cov8" title="1">{
        var rules []*Rule
        for ruleIndex, andList := range tables </span><span class="cov8" title="1">{
                var orConds []Condition

                for _, orList := range andList </span><span class="cov8" title="1">{
                        var catConds []Condition
                        for _, cat := range orList </span><span class="cov8" title="1">{
                                catConds = append(catConds, NewCategoryCond(cat))
                        }</span>
                        <span class="cov8" title="1">orConds = append(orConds, NewOrCond(catConds...))</span>
                }
                <span class="cov8" title="1">rules = append(rules, &amp;Rule{
                        RuleId: RuleIdType(ruleIndex),
                        Cond:   NewAndCond(orConds...),
                })</span>
        }
        <span class="cov8" title="1">return &amp;RuleRepo{Rules: rules}</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package engine

import (
        "encoding/json"
        "github.com/atlasgurus/rulestone/cateng"
        "github.com/atlasgurus/rulestone/condition"
        "github.com/atlasgurus/rulestone/objectmap"
        "github.com/atlasgurus/rulestone/types"
        "github.com/zyedidia/generic/hashmap"
        "github.com/zyedidia/generic/hashset"
        "gopkg.in/yaml.v3"
        "io"
        "math"
        "os"
        "path/filepath"
        "strings"
)

type ExternalRule struct {
        Metadata   map[string]interface{} `json:"metadata,omitempty"`
        Expression string                 `json:"expression"`
}

type RuleApi struct {
        ctx *types.AppContext
}

type InternalRule struct {
        Metadata  map[string]interface{}
        Condition condition.Condition
}

func externalToInternalRule(rule *ExternalRule) (*InternalRule, error) <span class="cov8" title="1">{
        cond := condition.NewExprCondition(rule.Expression)
        if cond.GetKind() == condition.ErrorCondKind </span><span class="cov0" title="0">{
                return nil, cond.(*condition.ErrorCondition).Err
        }</span>
        <span class="cov8" title="1">return &amp;InternalRule{
                Metadata:  rule.Metadata,
                Condition: cond}, nil</span>
}

func (api *RuleApi) ReadRules(r io.Reader, fileType string) ([]InternalRule, error) <span class="cov8" title="1">{
        var result []ExternalRule

        switch strings.ToLower(fileType) </span>{
        case "json":<span class="cov0" title="0">
                decoder := json.NewDecoder(r)
                if err := decoder.Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                        return nil, api.ctx.Errorf("error parsing JSON: %s", err)
                }</span>
        case "yaml", "yml":<span class="cov8" title="1">
                decoder := yaml.NewDecoder(r)
                if err := decoder.Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                        return nil, api.ctx.Errorf("error parsing YAML: %s", err)
                }</span>
        default:<span class="cov0" title="0">
                return nil, api.ctx.Errorf("unsupported file type: %s", fileType)</span>
        }

        <span class="cov8" title="1">internalRules := make([]InternalRule, len(result))
        for i, rule := range result </span><span class="cov8" title="1">{
                internalRule, err := externalToInternalRule(&amp;rule)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">internalRules[i] = *internalRule</span>
        }
        <span class="cov8" title="1">return internalRules, nil</span>
}

func NewRuleApi(ctx *types.AppContext) *RuleApi <span class="cov8" title="1">{
        return &amp;RuleApi{ctx: ctx}
}</span>

type RuleEngineRepo struct {
        Rules   []*GeneralRuleRecord
        ctx     *types.AppContext
        ruleApi *RuleApi
}

func (repo *RuleEngineRepo) Register(f *InternalRule) uint <span class="cov8" title="1">{
        result := uint(len(repo.Rules))
        repo.Rules = append(repo.Rules, &amp;GeneralRuleRecord{f, result})
        return result
}</span>

func (repo *RuleEngineRepo) RegisterRuleFromString(rule string, format string) (uint, error) <span class="cov0" title="0">{
        r := strings.NewReader(rule)
        rules, err := repo.ruleApi.ReadRules(r, format)
        if err != nil </span><span class="cov0" title="0">{
                return math.MaxUint, err
        }</span>
        <span class="cov0" title="0">return repo.Register(&amp;rules[0]), nil</span>
}

func (repo *RuleEngineRepo) RegisterRulesFromFile(path string) ([]uint, error) <span class="cov8" title="1">{
        f, err := os.Open(path)
        if err != nil </span><span class="cov8" title="1">{
                return []uint{}, err
        }</span>
        <span class="cov8" title="1">defer f.Close()

        fileType := filepath.Ext(path)
        fileType = fileType[1:] // Remove the dot from the extension

        rules, err := repo.ruleApi.ReadRules(f, fileType)
        if err != nil </span><span class="cov0" title="0">{
                return []uint{}, err
        }</span>
        <span class="cov8" title="1">ruleIds := make([]uint, 0)
        for i := range rules </span><span class="cov8" title="1">{
                ruleId := repo.Register(&amp;rules[i])
                ruleIds = append(ruleIds, ruleId)
        }</span>
        <span class="cov8" title="1">return ruleIds, nil</span>
}

func RuleEngineRepoToCompareCondRepo(repo *RuleEngineRepo) (*CompareCondRepo, error) <span class="cov8" title="1">{
        result := CompareCondRepo{
                CondToCompareCondRecord:      types.NewHashMap[condition.Condition, *EvalCategoryRec](),
                CondToCategoryMap:            types.NewHashMap[condition.Condition, *hashmap.Map[condition.Operand, []condition.Operand]](),
                CondToStringMatcher:          types.NewHashMap[condition.Condition, *StringMatcher](),
                AttributeToCompareCondRecord: make(map[string]*hashset.Set[*EvalCategoryRec]),
                ObjectAttributeMapper:        objectmap.NewObjectAttributeMapper(repo),
                CondFactory:                  condition.NewFactory(),
                ctx:                          repo.ctx,
        }

        rootScope := &amp;ForEachScope{
                Path:         "",
                Element:      "", // Will match $.something reference
                NestingLevel: 0,
                ParentScope:  nil,
                AttrDictRec:  result.ObjectAttributeMapper.RootDictRec}

        for id, f := range repo.Rules </span><span class="cov8" title="1">{
                cond := result.ConvertToCategoryCondition(f.definition.Condition, rootScope)
                if cond.GetKind() == condition.ErrorCondKind </span><span class="cov0" title="0">{
                        return nil, cond.(*condition.ErrorCondition).Err
                }</span>
                <span class="cov8" title="1">result.RuleRepo.Register(condition.NewRule(condition.RuleIdType(id), cond))</span>
        }

        // Build the string matchers
        <span class="cov8" title="1">result.CondToStringMatcher.Each(func(key condition.Condition, value *StringMatcher) </span><span class="cov8" title="1">{ value.Build() }</span>)

        <span class="cov8" title="1">return &amp;result, nil</span>
}

type RuleEngineMetrics struct {
        NumCatEvals uint64
}

type RuleEngine struct {
        repo         *RuleEngineRepo
        catEngine    *cateng.CategoryEngine
        compCondRepo *CompareCondRepo
        Metrics      RuleEngineMetrics
}

func NewRuleEngine(repo *RuleEngineRepo) (*RuleEngine, error) <span class="cov8" title="1">{
        compCondRepo, err := RuleEngineRepoToCompareCondRepo(repo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">catEngine := cateng.NewCategoryEngine(&amp;compCondRepo.RuleRepo, &amp;cateng.Options{
                // TODO implement option passing
                OrOptimizationFreqThreshold:  0,
                AndOptimizationFreqThreshold: 1,
                Verbose:                      true,
        })

        return &amp;RuleEngine{repo: repo, catEngine: catEngine, compCondRepo: compCondRepo}, nil</span>
}

func (f *RuleEngine) MatchEvent(v interface{}) []condition.RuleIdType <span class="cov8" title="1">{
        matchingCompareCondRecords := types.NewHashSet[*EvalCategoryRec]()
        event := f.compCondRepo.ObjectAttributeMapper.MapObject(v,
                // Callback for each attribute of interest found in the mapped event
                func(addr []int) </span><span class="cov8" title="1">{
                        addrMatchId := objectmap.AddressMatchKey(addr)
                        catEvaluators, ok := f.compCondRepo.AttributeToCompareCondRecord[addrMatchId]
                        if ok </span><span class="cov8" title="1">{
                                catEvaluators.Each(
                                        func(catEvaluator *EvalCategoryRec) </span><span class="cov8" title="1">{
                                                matchingCompareCondRecords.Put(catEvaluator)
                                        }</span>)
                        }
                })
        <span class="cov8" title="1">var eventCategories []types.Category
        var FrameStack = [20]interface{}{event.Values}
        matchingCompareCondRecords.Each(func(catEvaluator *EvalCategoryRec) </span><span class="cov8" title="1">{
                f.Metrics.NumCatEvals++
                result := catEvaluator.Evaluate(event, FrameStack[:])
                switch r := result.(type) </span>{
                case condition.ErrorOperand:<span class="cov8" title="1"></span>
                        // TODO: find a way to report errors
                        // can't report every error, have to aggregate errors and report periodic statistics
                case condition.BooleanOperand:<span class="cov8" title="1">
                        cat := catEvaluator.GetCategory()
                        if r </span><span class="cov8" title="1">{
                                eventCategories = append(eventCategories, cat)
                        }</span>
                case *condition.ListOperand:<span class="cov8" title="1">
                        for _, c := range r.List </span><span class="cov8" title="1">{
                                cat := types.Category(c.(condition.IntOperand))
                                eventCategories = append(eventCategories, cat)
                        }</span>
                case condition.IntOperand:<span class="cov8" title="1">
                        if r != 0 </span><span class="cov0" title="0">{
                                eventCategories = append(eventCategories, types.Category(r))
                        }</span>
                default:<span class="cov0" title="0">
                        panic("should not get here")</span>
                }
        })
        <span class="cov8" title="1">f.compCondRepo.ObjectAttributeMapper.FreeObjects()
        return f.catEngine.MatchEvent(eventCategories)</span>
}

func (f *RuleEngine) GetRuleDefinition(ruleId uint) *InternalRule <span class="cov0" title="0">{
        if ruleId &gt;= 0 &amp;&amp; int(ruleId) &gt;= 0 &amp;&amp; int(ruleId) &lt; len(f.repo.Rules) </span><span class="cov0" title="0">{
                return f.repo.Rules[ruleId].definition
        }</span> else<span class="cov0" title="0"> {
                return nil
        }</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package engine

import (
        "bytes"
        "fmt"
        "github.com/atlasgurus/rulestone/condition"
        "github.com/atlasgurus/rulestone/immutable"
        "github.com/atlasgurus/rulestone/objectmap"
        "github.com/atlasgurus/rulestone/types"
        "github.com/zyedidia/generic/hashmap"
        "github.com/zyedidia/generic/hashset"
        "go/ast"
        "go/parser"
        "go/printer"
        "go/token"
        "math"
        "regexp"
        "strconv"
        "strings"
        "time"
)

type RepoInterface interface {
        Register(f *InternalRule)
}

type GeneralRuleRecord struct {
        definition *InternalRule
        id         uint
}

// MapScalar Implement MapperConfig interface
func (repo *RuleEngineRepo) MapScalar(v interface{}) interface{} <span class="cov8" title="1">{
        return condition.NewInterfaceOperand(v, repo.ctx)
}</span>

func (repo *RuleEngineRepo) GetAppCtx() *types.AppContext <span class="cov8" title="1">{
        return repo.ctx
}</span>

func NewRuleEngineRepo() *RuleEngineRepo <span class="cov8" title="1">{
        ctx := types.NewAppContext()
        return &amp;RuleEngineRepo{ctx: ctx, ruleApi: NewRuleApi(ctx)}
}</span>

type CatEvaluatorKind int8

type CatEvaluator interface {
        Evaluate(event *objectmap.ObjectAttributeMap, frames []interface{}) (bool, error)
        GetCategory() types.Category
        immutable.SetElement
}

type EvalCategoryRec struct {
        Cat      types.Category
        Eval     condition.Operand
        AttrKeys []string
}

func (v *EvalCategoryRec) GetHash() uint64 <span class="cov8" title="1">{
        return uint64(v.Cat)
}</span>

func (v *EvalCategoryRec) Equals(element immutable.SetElement) bool <span class="cov8" title="1">{
        // Cryptographic hash can be used for equality check
        return v.GetHash() == element.(*EvalCategoryRec).GetHash()
}</span>

func (v *EvalCategoryRec) Evaluate(event *objectmap.ObjectAttributeMap, frames []interface{}) condition.Operand <span class="cov8" title="1">{
        return v.Eval.Evaluate(event, frames)
}</span>

func (v *EvalCategoryRec) GetCategory() types.Category <span class="cov8" title="1">{
        // Cryptographic hash can be used for equality check
        return v.Cat
}</span>

// CompareCondRepo contains mappings between filter Compare Conditions and attributes assigned to them.
// Identical Compare Conditions will be mapped to the same category.
type CompareCondRepo struct {
        AttributeToCompareCondRecord map[string]*hashset.Set[*EvalCategoryRec]
        CondToCompareCondRecord      *hashmap.Map[condition.Condition, *EvalCategoryRec]
        CondToCategoryMap            *hashmap.Map[condition.Condition, *hashmap.Map[condition.Operand, []condition.Operand]]
        CondToStringMatcher          *hashmap.Map[condition.Condition, *StringMatcher]
        EvalCategoryRecs             []*EvalCategoryRec
        RuleRepo                     condition.RuleRepo
        ObjectAttributeMapper        *objectmap.ObjectAttributeMapper
        CondFactory                  *condition.Factory
        ctx                          *types.AppContext
}

func (repo *CompareCondRepo) NewEvalCategoryRec(eval condition.Operand) *EvalCategoryRec <span class="cov8" title="1">{
        result := &amp;EvalCategoryRec{
                Cat:  types.Category(len(repo.EvalCategoryRecs) + 1),
                Eval: eval,
        }
        repo.EvalCategoryRecs = append(repo.EvalCategoryRecs, result)
        return result
}</span>

func (repo *CompareCondRepo) DiscardEvalCategoryRec(evalCategoryRec *EvalCategoryRec) <span class="cov8" title="1">{
        // Only need to support removing the most recently added evalCategoryRec
        if repo.EvalCategoryRecs[len(repo.EvalCategoryRecs)-1].Cat != evalCategoryRec.Cat </span><span class="cov0" title="0">{
                panic("Should not happen")</span>
        }
        // Remove the last one
        <span class="cov8" title="1">repo.EvalCategoryRecs = repo.EvalCategoryRecs[:len(repo.EvalCategoryRecs)-1]</span>
}

// ConvertToCategoryCondition this has to be called from the root condition or and/or/not boolean operator
func (repo *CompareCondRepo) ConvertToCategoryCondition(c condition.Condition, parentScope *ForEachScope) condition.Condition <span class="cov8" title="1">{
        var result condition.Condition
        switch c.GetKind() </span>{
        case condition.AndCondKind:<span class="cov0" title="0">
                result = repo.CondFactory.NewAndCond(types.MapSlice(
                        c.GetOperands(), func(c condition.Condition) condition.Condition </span><span class="cov0" title="0">{
                                return repo.ConvertToCategoryCondition(c, parentScope)
                        }</span>)...)
        case condition.OrCondKind:<span class="cov0" title="0">
                result = repo.CondFactory.NewOrCond(types.MapSlice(
                        c.GetOperands(), func(c condition.Condition) condition.Condition </span><span class="cov0" title="0">{
                                return repo.ConvertToCategoryCondition(c, parentScope)
                        }</span>)...)
        case condition.NotCondKind:<span class="cov0" title="0">
                result = repo.CondFactory.NewNotCond(repo.ConvertToCategoryCondition(c.GetOperands()[0], parentScope))</span>
        case condition.CategoryCondKind:<span class="cov0" title="0">
                panic("CategoryCondKind not expected")</span>
        case condition.CompareCondKind:<span class="cov0" title="0">
                result = repo.processCompareCondition(c.(*condition.CompareCondition), parentScope)</span>
        case condition.ExprCondKind:<span class="cov8" title="1">
                result = repo.processExprCondition(c.(*condition.ExprCondition), parentScope)</span>
        default:<span class="cov0" title="0">
                panic("should not happen")</span>
        }
        <span class="cov8" title="1">return result</span>
}

func (repo *CompareCondRepo) registerCatEvaluatorForAddress(attrAddress []int, catEvaluator *EvalCategoryRec) <span class="cov8" title="1">{
        if catEvaluator != nil </span><span class="cov8" title="1">{
                addrMatchKey := objectmap.AddressMatchKey(attrAddress)
                var condRecords *hashset.Set[*EvalCategoryRec]
                var ok bool
                if condRecords, ok = repo.AttributeToCompareCondRecord[addrMatchKey]; !ok </span><span class="cov8" title="1">{
                        condRecords = types.NewHashSet[*EvalCategoryRec]()
                        repo.AttributeToCompareCondRecord[addrMatchKey] = condRecords
                }</span>
                <span class="cov8" title="1">condRecords.Put(catEvaluator)
                catEvaluator.AttrKeys = append(catEvaluator.AttrKeys, addrMatchKey)</span>
        }
}

func (repo *CompareCondRepo) unregisterCatEvaluator(catEvaluator *EvalCategoryRec) <span class="cov8" title="1">{
        if catEvaluator != nil </span><span class="cov8" title="1">{
                for _, addrMatchKey := range catEvaluator.AttrKeys </span><span class="cov8" title="1">{
                        var condRecords *hashset.Set[*EvalCategoryRec]
                        var ok bool
                        if condRecords, ok = repo.AttributeToCompareCondRecord[addrMatchKey]; ok </span><span class="cov8" title="1">{
                                condRecords.Remove(catEvaluator)
                                if condRecords.Size() == 0 </span><span class="cov0" title="0">{
                                        delete(repo.AttributeToCompareCondRecord, addrMatchKey)
                                }</span>
                        }
                }
        }
}

func (repo *CompareCondRepo) genEvalForLogicalOp(
        op token.Token,
        xEval condition.Operand,
        yEval condition.Operand) condition.Operand <span class="cov8" title="1">{

        return repo.CondFactory.NewExprOperand(
                func(event *objectmap.ObjectAttributeMap, frames []interface{}) condition.Operand </span><span class="cov8" title="1">{
                        X := xEval.Evaluate(event, frames).Convert(condition.BooleanOperandKind)
                        if X.GetKind() == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                                return X
                        }</span>
                        <span class="cov8" title="1">Y := yEval.Evaluate(event, frames).Convert(condition.BooleanOperandKind)
                        if Y.GetKind() == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                                return Y
                        }</span>

                        <span class="cov8" title="1">switch op </span>{
                        case token.LAND:<span class="cov8" title="1">
                                return condition.NewBooleanOperand(bool(X.(condition.BooleanOperand)) &amp;&amp; bool(Y.(condition.BooleanOperand)))</span>
                        case token.LOR:<span class="cov0" title="0">
                                return condition.NewBooleanOperand(bool(X.(condition.BooleanOperand)) || bool(Y.(condition.BooleanOperand)))</span>
                        default:<span class="cov0" title="0">
                                panic("should not get here")</span>
                        }
                }, xEval, yEval)
}

func (repo *CompareCondRepo) genEvalForCompareOperands(
        compOp condition.CompareOp,
        xEval condition.Operand,
        yEval condition.Operand) condition.Operand <span class="cov8" title="1">{

        return repo.CondFactory.NewExprOperand(
                func(event *objectmap.ObjectAttributeMap, frames []interface{}) condition.Operand </span><span class="cov8" title="1">{
                        X := xEval.Evaluate(event, frames)
                        xKind := X.GetKind()
                        Y := yEval.Evaluate(event, frames)
                        yKind := Y.GetKind()
                        if xKind == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                                return X
                        }</span>
                        <span class="cov8" title="1">if yKind == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                                return Y
                        }</span>

                        // Convert toward the higher kind, e.g. int -&gt; float -&gt; bool -&gt; string
                        <span class="cov8" title="1">X, Y = condition.ReconcileOperands(X, Y)

                        switch compOp </span>{
                        case condition.CompareEqualOp:<span class="cov8" title="1">
                                return condition.NewBooleanOperand(X.Equals(Y))</span>
                        case condition.CompareNotEqualOp:<span class="cov8" title="1">
                                return condition.NewBooleanOperand(!X.Equals(Y))</span>
                        case condition.CompareGreaterOp:<span class="cov8" title="1">
                                return condition.NewBooleanOperand(X.Greater(Y))</span>
                        case condition.CompareGreaterOrEqualOp:<span class="cov8" title="1">
                                return condition.NewBooleanOperand(!Y.Greater(X))</span>
                        case condition.CompareLessOp:<span class="cov8" title="1">
                                return condition.NewBooleanOperand(Y.Greater(X))</span>
                        case condition.CompareLessOrEqualOp:<span class="cov0" title="0">
                                return condition.NewBooleanOperand(!X.Greater(Y))</span>
                        default:<span class="cov0" title="0">
                                panic("Not implemented")</span>
                        }
                }, xEval, yEval, repo.CondFactory.NewIntOperand(int64(compOp)))
}

// processCompareEqualToConstCondition: Special case equal compare against a constant that can be done via a hash lookup
func (repo *CompareCondRepo) processCompareEqualToConstCondition(
        compareCond *condition.CompareCondition, scope *ForEachScope) condition.Operand <span class="cov8" title="1">{

        var constOperand condition.Operand
        var varOperand condition.Operand
        if compareCond.LeftOperand.IsConst() </span><span class="cov0" title="0">{
                constOperand = compareCond.LeftOperand
                varOperand = compareCond.RightOperand
        }</span> else<span class="cov8" title="1"> if compareCond.RightOperand.IsConst() </span><span class="cov8" title="1">{
                constOperand = compareCond.RightOperand
                varOperand = compareCond.LeftOperand
        }</span> else<span class="cov0" title="0"> {
                panic("one of the operands must be a constant")</span>
        }

        <span class="cov8" title="1">return repo.processEvalForIsInConstantList(varOperand, []condition.Operand{constOperand}, scope)</span>
}

// processEvalForIsInConstantList
func (repo *CompareCondRepo) processEvalForIsInConstantList(
        varOperand condition.Operand, consOperandList []condition.Operand, scope *ForEachScope) condition.Operand <span class="cov8" title="1">{
        varOperand = repo.evalOperandAccess(repo.evalOperandAddress(varOperand, scope), scope)
        if varOperand.GetKind() == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                return varOperand
        }</span>

        // Create a dummy compare operation ignoring the consOperandList value and look it up
        <span class="cov8" title="1">dummyCondition := condition.NewCompareCond(condition.CompareEqualOp, varOperand, condition.NewIntOperand(0))
        categoryMap, seenCond := repo.CondToCategoryMap.Get(dummyCondition)
        if !seenCond </span><span class="cov8" title="1">{
                categoryMap = types.NewHashMap[condition.Operand, []condition.Operand]()
                repo.CondToCategoryMap.Put(dummyCondition, categoryMap)
        }</span>

        // Create an entry in the categoryMap for each of the consOperandList
        <span class="cov8" title="1">for _, constOperand := range consOperandList </span><span class="cov8" title="1">{
                categoryList, _ := categoryMap.Get(constOperand)
                categoryMap.Put(
                        constOperand,
                        append(categoryList, condition.NewIntOperand(int64(scope.Evaluator.GetCategory()))))
        }</span>

        <span class="cov8" title="1">if seenCond </span><span class="cov8" title="1">{
                // We have seen a condition identical to this one except for the const compare equal operand.
                // Unregister the duplicate address to evaluator mappings that may have been created.
                repo.unregisterCatEvaluator(scope.Evaluator)
                return nil
        }</span>

        <span class="cov8" title="1">return repo.CondFactory.NewExprOperand(
                func(event *objectmap.ObjectAttributeMap, frames []interface{}) condition.Operand </span><span class="cov8" title="1">{
                        X := varOperand.Evaluate(event, frames)
                        xKind := X.GetKind()
                        if xKind == condition.ErrorOperandKind </span><span class="cov8" title="1">{
                                return X
                        }</span>
                        <span class="cov8" title="1">catList, k := categoryMap.Get(X)
                        if k </span><span class="cov8" title="1">{
                                return condition.NewListOperand(catList)
                        }</span> else<span class="cov8" title="1"> {
                                return condition.IntConst0
                        }</span>
                }, varOperand)
}

func (repo *CompareCondRepo) processEvalForContains(
        varOperand condition.Operand, stringsToMatch []string, scope *ForEachScope) condition.Operand <span class="cov8" title="1">{
        varOperand = repo.evalOperandAccess(repo.evalOperandAddress(varOperand, scope), scope)
        if varOperand.GetKind() == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                return varOperand
        }</span>

        // Create a dummy compare operation ignoring the stringsToMatch value and look it up
        <span class="cov8" title="1">dummyCondition := condition.NewCompareCond(condition.CompareContainsOp, varOperand, condition.NewIntOperand(0))
        stringMatcher, seenCond := repo.CondToStringMatcher.Get(dummyCondition)
        if !seenCond </span><span class="cov8" title="1">{
                stringMatcher = NewStringMatcher()
                repo.CondToStringMatcher.Put(dummyCondition, stringMatcher)
        }</span>

        // Create an entry in the stringMatcher for each of the stringsToMatch
        <span class="cov8" title="1">for _, constOperand := range stringsToMatch </span><span class="cov8" title="1">{
                stringMatcher.AddPattern(constOperand, condition.NewIntOperand(int64(scope.Evaluator.GetCategory())))
        }</span>

        <span class="cov8" title="1">if seenCond </span><span class="cov8" title="1">{
                // We have seen a condition identical to this one except for the const compare equal operand.
                // Unregister the duplicate address to evaluator mappings that may have been created.
                repo.unregisterCatEvaluator(scope.Evaluator)
                return nil
        }</span>

        <span class="cov8" title="1">return repo.CondFactory.NewExprOperand(
                func(event *objectmap.ObjectAttributeMap, frames []interface{}) condition.Operand </span><span class="cov8" title="1">{
                        X := varOperand.Evaluate(event, frames).Convert(condition.StringOperandKind)
                        xKind := X.GetKind()
                        if xKind == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                                return X
                        }</span>
                        <span class="cov8" title="1">catList := stringMatcher.Match(string(X.(condition.StringOperand)))
                        if len(catList) &gt; 0 </span><span class="cov8" title="1">{
                                return condition.NewListOperand(catList)
                        }</span> else<span class="cov0" title="0"> {
                                return condition.IntConst0
                        }</span>
                }, varOperand)
}

type timeRange struct {
        start time.Time
        end   time.Time
}

func (repo *CompareCondRepo) evalIsInConstantListWithDateRange(
        valOperand condition.Operand,
        dateOperand condition.Operand,
        consOperandList []condition.Operand) condition.Operand <span class="cov8" title="1">{

        valueMap := types.NewHashMap[condition.Operand, timeRange]()

        for i := 0; i &lt; len(consOperandList); i += 3 </span><span class="cov8" title="1">{
                end := i + 3

                // prevent exceeding slice bounds
                if end &gt; len(consOperandList) </span><span class="cov0" title="0">{
                        return condition.NewErrorOperand(repo.ctx.LogError(fmt.Errorf("invalid date range")))
                }</span>

                <span class="cov8" title="1">value := consOperandList[i]
                date1 := consOperandList[i+1].Convert(condition.TimeOperandKind)
                if date1.GetHash() == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                        return date1
                }</span>
                <span class="cov8" title="1">date2 := consOperandList[i+2].Convert(condition.TimeOperandKind)
                if date2.GetHash() == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                        return date2
                }</span>
                <span class="cov8" title="1">valueMap.Put(value, timeRange{time.Time(date1.(condition.TimeOperand)), time.Time(date2.(condition.TimeOperand))})</span>
        }

        <span class="cov8" title="1">return repo.CondFactory.NewExprOperand(
                func(event *objectmap.ObjectAttributeMap, frames []interface{}) condition.Operand </span><span class="cov8" title="1">{
                        X := valOperand.Evaluate(event, frames)
                        xKind := X.GetKind()
                        if xKind == condition.NullOperandKind </span><span class="cov0" title="0">{
                                // Special case for TMSIS. May want to have a more general solution.
                                return condition.NewBooleanOperand(true)
                        }</span>
                        <span class="cov8" title="1">if xKind == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                                return X
                        }</span>
                        <span class="cov8" title="1">Y := dateOperand.Evaluate(event, frames)
                        yKind := Y.GetKind()
                        if yKind == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                                return Y
                        }</span>
                        <span class="cov8" title="1">var date condition.Operand
                        if yKind != condition.NullOperandKind </span><span class="cov8" title="1">{
                                date = Y.Convert(condition.TimeOperandKind)
                                if date.GetKind() != condition.TimeOperandKind </span><span class="cov0" title="0">{
                                        return condition.NewErrorOperand(repo.ctx.LogError(fmt.Errorf("invalid date range")))
                                }</span>
                        }
                        <span class="cov8" title="1">dateRange, k := valueMap.Get(X)
                        if k </span><span class="cov8" title="1">{
                                if yKind == condition.NullOperandKind </span><span class="cov0" title="0">{
                                        // Special case for TMSIS. Missing date is considered to be in the range.
                                        return condition.NewBooleanOperand(true)
                                }</span>
                                <span class="cov8" title="1">return condition.NewBooleanOperand(
                                        !(dateRange.start.After(time.Time(date.(condition.TimeOperand))) ||
                                                dateRange.end.Before(time.Time(date.(condition.TimeOperand)))))</span>
                        } else<span class="cov0" title="0"> {
                                return condition.NewBooleanOperand(false)
                        }</span>
                }, valOperand, dateOperand)
}

func (repo *CompareCondRepo) genEvalForCompareCondition(
        compareCond *condition.CompareCondition, scope *ForEachScope) condition.Operand <span class="cov8" title="1">{

        lOperand := repo.evalOperandAccess(repo.evalOperandAddress(compareCond.LeftOperand, scope), scope)
        if lOperand.GetKind() == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                return lOperand
        }</span>

        <span class="cov8" title="1">rOperand := repo.evalOperandAccess(repo.evalOperandAddress(compareCond.RightOperand, scope), scope)
        if rOperand.GetKind() == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                return rOperand
        }</span>
        <span class="cov8" title="1">return repo.genEvalForCompareOperands(compareCond.CompareOp, lOperand, rOperand)</span>
}

func (repo *CompareCondRepo) genEvalForExprCondition(
        exprCondition *condition.ExprCondition, scope *ForEachScope) condition.Operand <span class="cov8" title="1">{
        // Convert the expression to an AST node tree
        node, err := parser.ParseExpr(exprCondition.Expr)

        if err != nil </span><span class="cov0" title="0">{
                return condition.NewErrorOperand(repo.ctx.LogError(err))
        }</span>
        <span class="cov8" title="1">return repo.evalAstNode(node, scope)</span>
}

func (repo *CompareCondRepo) processCompareCondition(
        compareCond *condition.CompareCondition, scope *ForEachScope) condition.Condition <span class="cov8" title="1">{
        if scope.ParentScope != nil </span><span class="cov0" title="0">{
                panic("must be called from root scope")</span>
        }

        <span class="cov8" title="1">oldEvalCondRec, ok := repo.CondToCompareCondRecord.Get(compareCond)
        evalCatRec := scope.Evaluator
        if ok </span><span class="cov8" title="1">{
                if evalCatRec != nil </span><span class="cov8" title="1">{
                        // We have seen another condition identical to this one.  Use its category instead of the new one.
                        repo.DiscardEvalCategoryRec(evalCatRec)

                        // Remove address to the new eval record registration too.
                        repo.unregisterCatEvaluator(evalCatRec)
                        scope.Evaluator = nil
                }</span>
                <span class="cov8" title="1">evalCatRec = oldEvalCondRec</span>
        } else<span class="cov8" title="1"> {
                if evalCatRec == nil </span><span class="cov0" title="0">{
                        evalCatRec = repo.NewEvalCategoryRec(nil)
                        // Capture evaluator record so that we can register nested attribute access against it.
                        scope.Evaluator = evalCatRec
                        defer scope.ResetEvaluator()
                }</span>

                <span class="cov8" title="1">var eval condition.Operand
                // Special case equal compare against a constant that can be done via a hash lookup
                if compareCond.CompareOp == condition.CompareEqualOp &amp;&amp;
                        (compareCond.LeftOperand.IsConst() || compareCond.RightOperand.IsConst()) </span><span class="cov8" title="1">{
                        eval = repo.processCompareEqualToConstCondition(compareCond, scope)
                }</span> else<span class="cov8" title="1"> {
                        eval = repo.genEvalForCompareCondition(compareCond, scope)
                }</span>
                <span class="cov8" title="1">if eval != nil &amp;&amp; eval.GetKind() == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                        return condition.NewErrorCondition(eval.(condition.ErrorOperand))
                }</span>
                <span class="cov8" title="1">evalCatRec.Eval = eval

                repo.CondToCompareCondRecord.Put(compareCond, evalCatRec)</span>
        }
        <span class="cov8" title="1">return condition.NewCategoryCond(evalCatRec.GetCategory())</span>
}

// ForEachScope keeps track of the local scope data.
// Each for_all, for_some or for_each filter element starts a new scope with its index element
// and path pointing to the data attribute over which the element iterates in this scope.
// The scope's element is available from all the nested scopes both during the filter build time
// as the parentScope parameter and at runtime via array of attribute addresses, one for each
// ancestor scope.
type ForEachScope struct {
        // Path, e.g. $.members or $member.children.
        // Each path consist of the outer path reference (e.g. $ for root or $member for path to
        // the member element) and the path to a nested array element.  The address of the denoted
        // element is therefore a concatenation of the address of the parent element's path
        // and the address of the path of the current element.
        Path         string
        Element      string
        NestingLevel int
        ParentScope  *ForEachScope
        Evaluator    *EvalCategoryRec
        AttrDictRec  *objectmap.AttrDictionaryRec
}

func (scope *ForEachScope) ResetEvaluator() <span class="cov8" title="1">{
        scope.Evaluator = nil
}</span>

type EvalCondFunc func(event *objectmap.ObjectAttributeMap, frames []interface{}) (bool, error)

func (repo *CompareCondRepo) genEvalForAndCondition(
        cond *condition.AndCond, parentScope *ForEachScope) condition.Operand <span class="cov0" title="0">{
        var condEvaluators []*condition.ExprOperand
        for _, c := range cond.Operands </span><span class="cov0" title="0">{
                eval := repo.genEvalForCondition(c, parentScope)
                if eval.GetKind() == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                        return eval
                }</span>
                <span class="cov0" title="0">condEvaluators = append(condEvaluators, eval.(*condition.ExprOperand))</span>
        }

        <span class="cov0" title="0">return repo.CondFactory.NewExprOperand(
                func(event *objectmap.ObjectAttributeMap, frames []interface{}) condition.Operand </span><span class="cov0" title="0">{
                        for _, eval := range condEvaluators </span><span class="cov0" title="0">{
                                result := eval.Func(event, frames)
                                if result.GetKind() == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                                        return result
                                }</span> else<span class="cov0" title="0"> if !result.(condition.BooleanOperand) </span><span class="cov0" title="0">{
                                        return condition.NewBooleanOperand(false)
                                }</span>
                        }
                        // Return true unless at least one is false
                        <span class="cov0" title="0">return condition.NewBooleanOperand(true)</span>
                }, types.MapSlice(condEvaluators, func(o *condition.ExprOperand) condition.Operand <span class="cov0" title="0">{ return o }</span>)...)
}

func (repo *CompareCondRepo) genEvalForOrCondition(
        cond *condition.OrCond, parentScope *ForEachScope) condition.Operand <span class="cov0" title="0">{
        var condEvaluators []*condition.ExprOperand
        for _, c := range cond.Operands </span><span class="cov0" title="0">{
                eval := repo.genEvalForCondition(c, parentScope)
                if eval.GetKind() == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                        return eval
                }</span>
                <span class="cov0" title="0">condEvaluators = append(condEvaluators, eval.(*condition.ExprOperand))</span>
        }

        <span class="cov0" title="0">return repo.CondFactory.NewExprOperand(
                func(event *objectmap.ObjectAttributeMap, frames []interface{}) condition.Operand </span><span class="cov0" title="0">{
                        for _, eval := range condEvaluators </span><span class="cov0" title="0">{
                                result := eval.Func(event, frames)
                                if result.GetKind() == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                                        return result
                                }</span> else<span class="cov0" title="0"> if result.(condition.BooleanOperand) </span><span class="cov0" title="0">{
                                        return condition.NewBooleanOperand(true)
                                }</span>
                        }
                        // Return true unless at least one is false
                        <span class="cov0" title="0">return condition.NewBooleanOperand(false)</span>
                }, types.MapSlice(condEvaluators, func(o *condition.ExprOperand) condition.Operand <span class="cov0" title="0">{ return o }</span>)...)
}

func (repo *CompareCondRepo) genEvalForNotCondition(
        cond *condition.NotCond, parentScope *ForEachScope) condition.Operand <span class="cov0" title="0">{
        eval := repo.genEvalForCondition(cond.Operand, parentScope)
        if eval.GetKind() == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                return eval
        }</span>

        <span class="cov0" title="0">return repo.CondFactory.NewExprOperand(
                func(event *objectmap.ObjectAttributeMap, frames []interface{}) condition.Operand </span><span class="cov0" title="0">{
                        result := eval.Evaluate(event, frames)
                        if result.GetKind() == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                                return result
                        }</span> else<span class="cov0" title="0"> {
                                return condition.NewBooleanOperand(!bool(result.(condition.BooleanOperand)))
                        }</span>
                }, eval)
}

func (repo *CompareCondRepo) genEvalForCondition(
        c condition.Condition, parentScope *ForEachScope) condition.Operand <span class="cov8" title="1">{
        switch c.GetKind() </span>{
        case condition.AndCondKind:<span class="cov0" title="0">
                return repo.genEvalForAndCondition(c.(*condition.AndCond), parentScope)</span>
        case condition.OrCondKind:<span class="cov0" title="0">
                return repo.genEvalForOrCondition(c.(*condition.OrCond), parentScope)</span>
        case condition.NotCondKind:<span class="cov0" title="0">
                return repo.genEvalForNotCondition(c.(*condition.NotCond), parentScope)</span>
        case condition.CategoryCondKind:<span class="cov0" title="0">
                panic("CategoryCondKind not expected")</span>
        case condition.CompareCondKind:<span class="cov0" title="0">
                return repo.genEvalForCompareCondition(c.(*condition.CompareCondition), parentScope)</span>
        case condition.ExprCondKind:<span class="cov8" title="1">
                return repo.genEvalForExprCondition(c.(*condition.ExprCondition), parentScope)</span>
        default:<span class="cov0" title="0">
                panic(fmt.Sprintf("should not happen %v", c.GetKind()))</span>
        }
}

func (repo *CompareCondRepo) setupEvalForEach(parentScope *ForEachScope, element string, path string) (
        *objectmap.AttributeAddress, *ForEachScope, error) <span class="cov8" title="1">{
        // arrayAddress points to the array
        if arrayAddress, err := getAttributePathAddress(path+"[]", parentScope); err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span> else<span class="cov8" title="1"> {
                arrPath := path + "[]"
                scope, ePath := expandPath(arrPath, parentScope)
                addr, err := scope.AttrDictRec.AttributePathToAddress(ePath)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
                <span class="cov8" title="1">newDictRec := scope.AttrDictRec.AddressToDictionaryRec(addr)

                newPath := scope.AttrDictRec.AddressToFullPath(addr)
                if arrayAddress.ParentParameterIndex != scope.NestingLevel </span><span class="cov0" title="0">{
                        panic("why?")</span>
                }
                <span class="cov8" title="1">newScope := &amp;ForEachScope{
                        // ARRAY_ELEMENT issue
                        Path:         newPath, // add explicit indexing to the path
                        Element:      element,
                        NestingLevel: parentScope.NestingLevel + 1,
                        ParentScope:  parentScope,
                        AttrDictRec:  newDictRec}

                return &amp;objectmap.AttributeAddress{
                        Address:              addr,
                        Path:                 newPath,
                        ParentParameterIndex: scope.NestingLevel,
                        FullAddress:          scope.AttrDictRec.AddressToFullAddress(addr)}, newScope, nil</span>
        }
}

func (repo *CompareCondRepo) genEvalForAllCondition(
        path string, element string, cond condition.Condition, parentScope *ForEachScope) condition.Operand <span class="cov8" title="1">{

        arrayAddress, newScope, err := repo.setupEvalForEach(parentScope, element, path)
        if err != nil </span><span class="cov0" title="0">{
                return condition.NewErrorOperand(err)
        }</span> else<span class="cov8" title="1"> {
                nestingLevel := newScope.NestingLevel

                eval := repo.genEvalForCondition(cond, newScope)
                if eval.GetKind() == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                        return eval
                }</span>

                <span class="cov8" title="1">return repo.CondFactory.NewExprOperand(
                        func(event *objectmap.ObjectAttributeMap, frames []interface{}) condition.Operand </span><span class="cov8" title="1">{
                                numElements, err := event.GetNumElementsAtAddress(arrayAddress, frames)
                                if err != nil </span><span class="cov0" title="0">{
                                        return condition.NewErrorOperand(err)
                                }</span>

                                <span class="cov8" title="1">parentsFrame := frames[arrayAddress.ParentParameterIndex]
                                currentAddressLen := len(arrayAddress.Address)
                                currentAddress := types.GetIntSlice()
                                currentAddress = append(currentAddress, arrayAddress.Address...)
                                currentAddress = append(currentAddress, 0)
                                var result condition.Operand = condition.NewBooleanOperand(true)
                                for i := 0; i &lt; numElements; i++ </span><span class="cov8" title="1">{
                                        currentAddress[currentAddressLen] = i
                                        newFrame := objectmap.GetNestedAttributeByAddress(parentsFrame, currentAddress)
                                        if newFrame == nil </span><span class="cov0" title="0">{
                                                // TODO: record diagnostics somewhere that attribute is not available
                                                // we don't want to do for all, maybe have a metric of how many times the attribute
                                                // could not be accessed
                                                result = condition.NewBooleanOperand(false)
                                                break</span>
                                        }
                                        <span class="cov8" title="1">frames[nestingLevel] = newFrame
                                        result = eval.Evaluate(event, frames)
                                        if result.GetKind() == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                                                break</span>
                                        } else<span class="cov8" title="1"> if !result.(condition.BooleanOperand) </span><span class="cov0" title="0">{
                                                break</span>
                                        }
                                }
                                // Return true unless at least one is false
                                <span class="cov8" title="1">types.PutIntSlice(currentAddress)
                                return result</span>
                        }, eval)
        }
}

func (repo *CompareCondRepo) processForAllCondition(
        path string, element string, cond condition.Condition, parentScope *ForEachScope) condition.Condition <span class="cov8" title="1">{
        dummyCond := condition.NewAndCond(condition.NewExprCondition("forAll"), condition.NewExprCondition(path), condition.NewExprCondition(element), cond)
        evalCatRec, ok := repo.CondToCompareCondRecord.Get(dummyCond)
        if !ok </span><span class="cov8" title="1">{
                eval := repo.genEvalForAllCondition(path, element, cond, parentScope)

                if eval.GetKind() == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                        return condition.NewErrorCondition(eval.(condition.ErrorOperand))
                }</span>
                <span class="cov8" title="1">evalCatRec = repo.NewEvalCategoryRec(eval)
                repo.CondToCompareCondRecord.Put(dummyCond, evalCatRec)
                // ARRAY_ELEMENT issue
                if arrayAddress, err := getAttributePathAddress(path+"[]", parentScope); err != nil </span><span class="cov0" title="0">{
                        panic("should not happen: failed the check that passed earlier")</span>
                } else<span class="cov8" title="1"> {
                        repo.registerCatEvaluatorForAddress(arrayAddress.FullAddress, evalCatRec)
                }</span>
        }
        <span class="cov8" title="1">return condition.NewCategoryCond(evalCatRec.GetCategory())</span>
}

func (repo *CompareCondRepo) genEvalForSomeCondition(
        path string, element string, cond condition.Condition, parentScope *ForEachScope) condition.Operand <span class="cov8" title="1">{
        // ARRAY_ELEMENT issue
        arrayAddress, newScope, err := repo.setupEvalForEach(parentScope, element, path)
        if err != nil </span><span class="cov0" title="0">{
                return condition.NewErrorOperand(err)
        }</span> else<span class="cov8" title="1"> {
                nestingLevel := newScope.NestingLevel
                eval := repo.genEvalForCondition(cond, newScope)
                if eval.GetKind() == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                        return eval
                }</span>

                <span class="cov8" title="1">return repo.CondFactory.NewExprOperand(
                        func(event *objectmap.ObjectAttributeMap, frames []interface{}) condition.Operand </span><span class="cov8" title="1">{
                                numElements, err := event.GetNumElementsAtAddress(arrayAddress, frames)
                                if err != nil </span><span class="cov0" title="0">{
                                        return condition.NewErrorOperand(err)
                                }</span>

                                <span class="cov8" title="1">parentsFrame := frames[arrayAddress.ParentParameterIndex]
                                currentAddressLen := len(arrayAddress.Address)
                                currentAddress := types.GetIntSlice()
                                currentAddress = append(currentAddress, arrayAddress.Address...)
                                currentAddress = append(currentAddress, 0)
                                var result condition.Operand = condition.NewBooleanOperand(false)
                                for i := 0; i &lt; numElements; i++ </span><span class="cov8" title="1">{
                                        currentAddress[currentAddressLen] = i
                                        newFrame := objectmap.GetNestedAttributeByAddress(parentsFrame, currentAddress)
                                        if newFrame == nil </span><span class="cov0" title="0">{
                                                // TODO: record diagnostics somewhere that attribute is not available
                                                // we don't want to do for all, maybe have a metric of how many times the attribute
                                                // could not be accessed
                                                break</span>
                                        }
                                        <span class="cov8" title="1">frames[nestingLevel] = newFrame
                                        result = eval.Evaluate(event, frames)
                                        if result.GetKind() == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                                                break</span>
                                        } else<span class="cov8" title="1"> if result.(condition.BooleanOperand) </span><span class="cov8" title="1">{
                                                break</span>
                                        }
                                }
                                // Return true unless at least one is false
                                <span class="cov8" title="1">types.PutIntSlice(currentAddress)

                                return result</span>
                        }, eval)
        }
}

func (repo *CompareCondRepo) processForSomeCondition(
        path string, element string, cond condition.Condition, parentScope *ForEachScope) condition.Condition <span class="cov8" title="1">{
        dummyCond := condition.NewAndCond(condition.NewExprCondition("forSome"), condition.NewExprCondition(path), condition.NewExprCondition(element), cond)
        evalCatRec, ok := repo.CondToCompareCondRecord.Get(dummyCond)
        if !ok </span><span class="cov8" title="1">{
                eval := repo.genEvalForSomeCondition(path, element, cond, parentScope)
                if eval.GetKind() == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                        return condition.NewErrorCondition(eval.(condition.ErrorOperand))
                }</span>

                <span class="cov8" title="1">evalCatRec = repo.NewEvalCategoryRec(eval)
                repo.CondToCompareCondRecord.Put(dummyCond, evalCatRec)
                // ARRAY_ELEMENT issue
                if arrayAddress, err := getAttributePathAddress(path+"[]", parentScope); err != nil </span><span class="cov0" title="0">{
                        //if elementAddress, err := getAttributePathAddress(repo, cond.Path, parentScope); err != nil {
                        panic("should not happen: failed the check that passed earlier")</span>
                } else<span class="cov8" title="1"> {
                        repo.registerCatEvaluatorForAddress(arrayAddress.FullAddress, evalCatRec)
                }</span>
        }
        <span class="cov8" title="1">return condition.NewCategoryCond(evalCatRec.GetCategory())</span>
}

func negateIfTrue(cond condition.Condition, negate bool) condition.Condition <span class="cov8" title="1">{
        if negate </span><span class="cov8" title="1">{
                return condition.NewNotCond(cond)
        }</span> else<span class="cov8" title="1"> {
                return cond
        }</span>
}

func (repo *CompareCondRepo) processCondNode(node ast.Node, negate bool, scope *ForEachScope) condition.Condition <span class="cov8" title="1">{
        switch n := node.(type) </span>{
        case *ast.CallExpr:<span class="cov8" title="1">
                funcName := n.Fun.(*ast.Ident).Name
                switch funcName </span>{
                case "regexpMatch":<span class="cov8" title="1">
                        return negateIfTrue(repo.processBoolFunc(funcRegexpMatch, n, scope), negate)</span>
                case "hasValue":<span class="cov8" title="1">
                        return negateIfTrue(repo.processBoolFunc(funcHasValue, n, scope), negate)</span>
                case "isEqualToAnyWithDate":<span class="cov8" title="1">
                        return negateIfTrue(repo.processBoolFunc(funcIsEqualToAnyWithDate, n, scope), negate)</span>
                case "isEqualToAny":<span class="cov8" title="1">
                        return negateIfTrue(repo.processIsEqualToAny(n, scope), negate)</span>
                case "containsAny":<span class="cov8" title="1">
                        return negateIfTrue(repo.processContains(n, scope), negate)</span>
                case "forAll":<span class="cov8" title="1">
                        return negateIfTrue(repo.processForAllFunc(n, scope), negate)</span>
                case "forSome":<span class="cov8" title="1">
                        return negateIfTrue(repo.processForSomeFunc(n, scope), negate)</span>
                default:<span class="cov0" title="0">
                        return condition.NewErrorCondition(fmt.Errorf("unsupported function: %s", funcName))</span>
                }
        case *ast.BinaryExpr:<span class="cov8" title="1">
                if negate </span><span class="cov8" title="1">{
                        switch n.Op </span>{
                        case token.LAND:<span class="cov8" title="1">
                                return repo.CondFactory.NewOrCond(repo.processCondNode(n.X, true, scope), repo.processCondNode(n.Y, true, scope))</span>
                        case token.LOR:<span class="cov0" title="0">
                                return repo.CondFactory.NewAndCond(repo.processCondNode(n.X, true, scope), repo.processCondNode(n.Y, true, scope))</span>
                        case token.EQL, token.LSS, token.GTR, token.NEQ, token.LEQ, token.GEQ:<span class="cov8" title="1">
                                return repo.processCompareBinaryExpr(n, negate, scope)</span>
                        default:<span class="cov0" title="0">
                                return condition.NewErrorCondition(
                                        repo.ctx.Errorf("unsupported operator: %s", n.Op.String()))</span>
                        }
                } else<span class="cov8" title="1"> {
                        switch n.Op </span>{
                        case token.LAND:<span class="cov8" title="1">
                                return repo.CondFactory.NewAndCond(repo.processCondNode(n.X, false, scope), repo.processCondNode(n.Y, false, scope))</span>
                        case token.LOR:<span class="cov8" title="1">
                                return repo.CondFactory.NewOrCond(repo.processCondNode(n.X, false, scope), repo.processCondNode(n.Y, false, scope))</span>
                        case token.EQL, token.LSS, token.GTR, token.NEQ, token.LEQ, token.GEQ:<span class="cov8" title="1">
                                return repo.processCompareBinaryExpr(n, negate, scope)</span>
                        default:<span class="cov0" title="0">
                                return condition.NewErrorCondition(
                                        repo.ctx.Errorf("unsupported operator: %s", n.Op.String()))</span>
                        }
                }
        case *ast.UnaryExpr:<span class="cov8" title="1">
                switch n.Op </span>{
                case token.NOT:<span class="cov8" title="1">
                        return repo.processCondNode(n.X, !negate, scope)</span>
                default:<span class="cov0" title="0">
                        return condition.NewErrorCondition(
                                repo.ctx.Errorf("unsupported operator: %s", n.Op.String()))</span>
                }
        case *ast.ParenExpr:<span class="cov8" title="1">
                return repo.processCondNode(n.X, negate, scope)</span>
        default:<span class="cov0" title="0">
                return condition.NewErrorCondition(
                        repo.ctx.Errorf("unsupported node type: %v", node))</span>
        }
}

type boolFuncT func(repo *CompareCondRepo, n *ast.CallExpr, scope *ForEachScope) condition.Operand

func (repo *CompareCondRepo) processBoolFunc(boolFunc boolFuncT, n *ast.CallExpr, scope *ForEachScope) condition.Condition <span class="cov8" title="1">{
        evalCatRec := repo.NewEvalCategoryRec(nil)
        if scope.Evaluator != nil </span><span class="cov0" title="0">{
                panic("Should not happen")</span>
        }
        // Set evaluator record so that we can register nested attribute addresses access against it.
        <span class="cov8" title="1">scope.Evaluator = evalCatRec
        defer scope.ResetEvaluator()

        resultOperand := boolFunc(repo, n, scope)
        if resultOperand.GetKind() == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                return condition.NewErrorCondition(resultOperand.(condition.ErrorOperand))
        }</span>

        <span class="cov8" title="1">return repo.processCompareCondition(condition.NewCompareCond(condition.CompareEqualOp, resultOperand, condition.NewBooleanOperand(true)), scope)</span>
}

func (repo *CompareCondRepo) processIsEqualToAny(n *ast.CallExpr, scope *ForEachScope) condition.Condition <span class="cov8" title="1">{
        evalCatRec := repo.NewEvalCategoryRec(nil)
        if scope.Evaluator != nil </span><span class="cov0" title="0">{
                panic("Should not happen")</span>
        }
        // Set evaluator record so that we can register nested attribute addresses access against it.
        <span class="cov8" title="1">scope.Evaluator = evalCatRec
        defer scope.ResetEvaluator()

        if len(n.Args) &lt; 2 </span><span class="cov0" title="0">{
                return condition.NewErrorCondition(fmt.Errorf("wrong number of arguments for isEqualToAny() function"))
        }</span>

        <span class="cov8" title="1">argOperands := types.MapSlice(n.Args, func(o ast.Expr) condition.Operand </span><span class="cov8" title="1">{ return repo.evalAstNode(o, scope) }</span>)
        <span class="cov8" title="1">firstErrorOperand := types.FindFirstInSlice(
                argOperands, func(o condition.Operand) bool </span><span class="cov8" title="1">{ return o.GetKind() == condition.ErrorOperandKind }</span>)
        <span class="cov8" title="1">if firstErrorOperand != nil </span><span class="cov0" title="0">{
                return condition.NewErrorCondition((*firstErrorOperand).(*condition.ErrorOperand).Err)
        }</span>

        <span class="cov8" title="1">constOperands := types.FilterSlice(argOperands[1:], func(o condition.Operand) bool </span><span class="cov8" title="1">{ return o.IsConst() }</span>)

        // See if we are comparing against const values. TODO: test this.
        <span class="cov8" title="1">if argOperands[0].IsConst() </span><span class="cov0" title="0">{
                for _, argOperand := range constOperands </span><span class="cov0" title="0">{
                        if argOperands[0].Equals(argOperand) </span><span class="cov0" title="0">{
                                // DefaultToTrue by apply NOT to a category that should never trigger
                                return condition.NewNotCond(condition.NewCategoryCond(evalCatRec.GetCategory()))
                        }</span>
                }
                <span class="cov0" title="0">if len(constOperands) == len(argOperands)-1 </span><span class="cov0" title="0">{
                        // All operands are constant and do not match
                        return condition.NewCategoryCond(evalCatRec.GetCategory())
                }</span>
        }

        <span class="cov8" title="1">if len(constOperands) != len(argOperands)-1 </span><span class="cov0" title="0">{
                // Not all operands in the match list are constants
                return condition.NewErrorCondition(fmt.Errorf("isEqualToAny() only supports constant match list"))
        }</span>

        <span class="cov8" title="1">eval := repo.processEvalForIsInConstantList(argOperands[0], argOperands[1:], scope)

        if eval != nil &amp;&amp; eval.GetKind() == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                return condition.NewErrorCondition(eval.(condition.ErrorOperand))
        }</span>
        <span class="cov8" title="1">evalCatRec.Eval = eval

        return condition.NewCategoryCond(evalCatRec.GetCategory())</span>
}

func (repo *CompareCondRepo) processForEachFunc(n *ast.CallExpr, kind string, scope *ForEachScope) condition.Condition <span class="cov0" title="0">{
        pathOperand, elementOperand, exprCond, err := repo.setupForEachOperands(n, scope)
        if err != nil </span><span class="cov0" title="0">{
                return condition.NewErrorCondition(err)
        }</span>

        <span class="cov0" title="0">switch kind </span>{
        case "all":<span class="cov0" title="0">
                return repo.processForAllCondition(
                        string(pathOperand.(condition.StringOperand)),
                        string(elementOperand.(condition.StringOperand)),
                        exprCond,
                        scope)</span>
        case "some":<span class="cov0" title="0">
                return repo.processForSomeCondition(
                        string(pathOperand.(condition.StringOperand)),
                        string(elementOperand.(condition.StringOperand)),
                        exprCond,
                        scope)</span>

        default:<span class="cov0" title="0">
                panic(fmt.Sprintf("Unknown kind %s", kind))</span>
        }
}

func (repo *CompareCondRepo) setupForEachOperands(n *ast.CallExpr, scope *ForEachScope) (
        condition.Operand, condition.Operand, condition.Condition, error) <span class="cov8" title="1">{
        if len(n.Args) != 3 </span><span class="cov0" title="0">{
                return nil, nil, nil, fmt.Errorf("wrong number of arguments for forAll() function")
        }</span>

        <span class="cov8" title="1">pathOperand := repo.evalAstNode(n.Args[0], scope)
        if pathOperand.GetKind() == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                return nil, nil, nil, pathOperand.(condition.ErrorOperand).Err
        }</span>

        <span class="cov8" title="1">if pathOperand.GetKind() != condition.StringOperandKind </span><span class="cov0" title="0">{
                return nil, nil, nil, fmt.Errorf("forAll() only supports string path")
        }</span>

        <span class="cov8" title="1">elementOperand := repo.evalAstNode(n.Args[1], scope)
        if elementOperand.GetKind() == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                return nil, nil, nil, elementOperand.(condition.ErrorOperand).Err
        }</span>

        <span class="cov8" title="1">if elementOperand.GetKind() != condition.StringOperandKind </span><span class="cov0" title="0">{
                return nil, nil, nil, fmt.Errorf("forAll() only supports string element operand")
        }</span>

        // We can't process the expression here because we have not evaluated the parent scope yet, which is defined by
        // the path and element operands. We will process the expression in the child scope.
        // First convert the ast expression back to string.
        // Then construct a ForAllCond with the string expression and pass it back to ConvertToCategoryCondition.
        <span class="cov8" title="1">var buf bytes.Buffer
        err := printer.Fprint(&amp;buf, token.NewFileSet(), n.Args[2])
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, err
        }</span>
        <span class="cov8" title="1">exprCond := condition.NewExprCondition(buf.String())
        return pathOperand, elementOperand, exprCond, nil</span>
}

func (repo *CompareCondRepo) processForAllFunc(n *ast.CallExpr, scope *ForEachScope) condition.Condition <span class="cov8" title="1">{
        pathOperand, elementOperand, exprCond, err := repo.setupForEachOperands(n, scope)
        if err != nil </span><span class="cov0" title="0">{
                return condition.NewErrorCondition(err)
        }</span>
        <span class="cov8" title="1">return repo.processForAllCondition(
                string(pathOperand.(condition.StringOperand)),
                string(elementOperand.(condition.StringOperand)),
                exprCond, scope)</span>
}

func (repo *CompareCondRepo) processForSomeFunc(n *ast.CallExpr, scope *ForEachScope) condition.Condition <span class="cov8" title="1">{
        pathOperand, elementOperand, exprCond, err := repo.setupForEachOperands(n, scope)
        if err != nil </span><span class="cov0" title="0">{
                return condition.NewErrorCondition(err)
        }</span>
        <span class="cov8" title="1">return repo.processForSomeCondition(
                string(pathOperand.(condition.StringOperand)),
                string(elementOperand.(condition.StringOperand)),
                exprCond, scope)</span>
}

func (repo *CompareCondRepo) funcForSome(n *ast.CallExpr, scope *ForEachScope) condition.Operand <span class="cov8" title="1">{
        pathOperand, elementOperand, exprCond, err := repo.setupForEachOperands(n, scope)
        if err != nil </span><span class="cov0" title="0">{
                return condition.NewErrorOperand(err)
        }</span>
        <span class="cov8" title="1">return repo.genEvalForSomeCondition(
                string(pathOperand.(condition.StringOperand)),
                string(elementOperand.(condition.StringOperand)),
                exprCond,
                scope)</span>
}

func (repo *CompareCondRepo) funcForAll(n *ast.CallExpr, scope *ForEachScope) condition.Operand <span class="cov0" title="0">{
        pathOperand, elementOperand, exprCond, err := repo.setupForEachOperands(n, scope)
        if err != nil </span><span class="cov0" title="0">{
                return condition.NewErrorOperand(err)
        }</span>
        <span class="cov0" title="0">return repo.genEvalForAllCondition(
                string(pathOperand.(condition.StringOperand)),
                string(elementOperand.(condition.StringOperand)),
                exprCond,
                scope)</span>
}

func (repo *CompareCondRepo) processContains(n *ast.CallExpr, scope *ForEachScope) condition.Condition <span class="cov8" title="1">{
        evalCatRec := repo.NewEvalCategoryRec(nil)
        if scope.Evaluator != nil </span><span class="cov0" title="0">{
                panic("Should not happen")</span>
        }
        // Set evaluator record so that we can register nested attribute addresses access against it.
        <span class="cov8" title="1">scope.Evaluator = evalCatRec
        defer scope.ResetEvaluator()

        if len(n.Args) &lt; 2 </span><span class="cov0" title="0">{
                return condition.NewErrorCondition(fmt.Errorf("wrong number of arguments for containsAny() function"))
        }</span>

        <span class="cov8" title="1">argOperands := types.MapSlice(n.Args,
                func(o ast.Expr) condition.Operand </span><span class="cov8" title="1">{ return repo.evalAstNode(o, scope) }</span>)
        <span class="cov8" title="1">firstErrorOperand := types.FindFirstInSlice(
                argOperands, func(o condition.Operand) bool </span><span class="cov8" title="1">{ return o.GetKind() == condition.ErrorOperandKind }</span>)
        <span class="cov8" title="1">if firstErrorOperand != nil </span><span class="cov0" title="0">{
                return condition.NewErrorCondition((*firstErrorOperand).(*condition.ErrorOperand).Err)
        }</span>

        <span class="cov8" title="1">constOperands := types.FilterSlice(argOperands[1:], func(o condition.Operand) bool </span><span class="cov8" title="1">{ return o.IsConst() }</span>)
        <span class="cov8" title="1">if len(constOperands) != len(argOperands)-1 </span><span class="cov0" title="0">{
                // Not all operands in the match list are constants
                return condition.NewErrorCondition(fmt.Errorf("containsAny() only supports constant string match list"))
        }</span>
        <span class="cov8" title="1">constStringOperands := types.MapSlice(constOperands,
                func(o condition.Operand) string </span><span class="cov8" title="1">{
                        return string(o.Convert(condition.StringOperandKind).(condition.StringOperand))
                }</span>)
        <span class="cov8" title="1">if len(constStringOperands) != len(constOperands) </span><span class="cov0" title="0">{
                // Not all operands in the match list are strings
                return condition.NewErrorCondition(fmt.Errorf("containsAny() only supports constant string match list"))
        }</span>

        <span class="cov8" title="1">eval := repo.processEvalForContains(argOperands[0], constStringOperands, scope)

        if eval != nil &amp;&amp; eval.GetKind() == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                return condition.NewErrorCondition(eval.(condition.ErrorOperand))
        }</span>
        <span class="cov8" title="1">evalCatRec.Eval = eval

        return condition.NewCategoryCond(evalCatRec.GetCategory())</span>
}

func (repo *CompareCondRepo) processCompareBinaryExpr(n *ast.BinaryExpr, negate bool, scope *ForEachScope) condition.Condition <span class="cov8" title="1">{
        var compareOp condition.CompareOp
        if negate </span><span class="cov8" title="1">{
                negate = false
                switch n.Op </span>{
                case token.EQL:<span class="cov8" title="1">
                        compareOp = condition.CompareEqualOp
                        negate = true</span>
                case token.LSS:<span class="cov0" title="0">
                        compareOp = condition.CompareGreaterOrEqualOp</span>
                case token.GTR:<span class="cov0" title="0">
                        compareOp = condition.CompareLessOrEqualOp</span>
                case token.NEQ:<span class="cov8" title="1">
                        compareOp = condition.CompareEqualOp</span>
                case token.LEQ:<span class="cov0" title="0">
                        compareOp = condition.CompareGreaterOp</span>
                case token.GEQ:<span class="cov0" title="0">
                        compareOp = condition.CompareLessOp</span>
                default:<span class="cov0" title="0">
                        return condition.NewErrorCondition(
                                repo.ctx.Errorf("unsupported operator: %s", n.Op.String()))</span>
                }
        } else<span class="cov8" title="1"> {
                switch n.Op </span>{
                case token.EQL:<span class="cov8" title="1">
                        compareOp = condition.CompareEqualOp</span>
                case token.LSS:<span class="cov8" title="1">
                        compareOp = condition.CompareLessOp</span>
                case token.GTR:<span class="cov8" title="1">
                        compareOp = condition.CompareGreaterOp</span>
                case token.NEQ:<span class="cov8" title="1">
                        negate = !negate
                        compareOp = condition.CompareEqualOp</span>
                case token.LEQ:<span class="cov0" title="0">
                        compareOp = condition.CompareLessOrEqualOp</span>
                case token.GEQ:<span class="cov8" title="1">
                        compareOp = condition.CompareGreaterOrEqualOp</span>
                default:<span class="cov0" title="0">
                        return condition.NewErrorCondition(
                                repo.ctx.Errorf("unsupported operator: %s", n.Op.String()))</span>
                }
        }

        <span class="cov8" title="1">evalCatRec := repo.NewEvalCategoryRec(nil)
        if scope.Evaluator != nil </span><span class="cov0" title="0">{
                panic("Should not happen")</span>
        }
        // Set evaluator record so that we can register nested attribute addresses access against it.
        <span class="cov8" title="1">scope.Evaluator = evalCatRec
        defer scope.ResetEvaluator()

        xOperand := repo.evalAstNode(n.X, scope)
        if xOperand.GetKind() == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                return condition.NewErrorCondition(xOperand.(condition.ErrorOperand))
        }</span>

        <span class="cov8" title="1">yOperand := repo.evalAstNode(n.Y, scope)
        if yOperand.GetKind() == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                return condition.NewErrorCondition(yOperand.(condition.ErrorOperand))
        }</span>

        <span class="cov8" title="1">if negate </span><span class="cov8" title="1">{
                return condition.NewNotCond(repo.processCompareCondition(condition.NewCompareCond(compareOp, xOperand, yOperand), scope))
        }</span> else<span class="cov8" title="1"> {
                return repo.processCompareCondition(condition.NewCompareCond(compareOp, xOperand, yOperand), scope)
        }</span>
}

func (repo *CompareCondRepo) processExprCondition(exprCondition *condition.ExprCondition, scope *ForEachScope) condition.Condition <span class="cov8" title="1">{
        if scope.ParentScope != nil </span><span class="cov0" title="0">{
                panic("must be called from root scope")</span>
        }

        // Convert the expression to an AST node tree
        <span class="cov8" title="1">node, err := parser.ParseExpr(exprCondition.Expr)

        if err != nil </span><span class="cov0" title="0">{
                return condition.NewErrorCondition(repo.ctx.LogError(err))
        }</span>

        // Process the AST node tree representation.
        // We will first recursively decent through logical operations to the nodes that
        // would evaluate to category conditions.
        <span class="cov8" title="1">return repo.processCondNode(node, false, scope)</span>
}

// preprocessAstExpr: convert ast expression to condition.Operand
func (repo *CompareCondRepo) preprocessAstExpr(node ast.Expr, scope *ForEachScope) condition.Operand <span class="cov8" title="1">{
        switch n := node.(type) </span>{
        case *ast.BasicLit:<span class="cov8" title="1">
                switch n.Kind </span>{
                case token.INT, token.FLOAT:<span class="cov8" title="1">
                        val, err := strconv.ParseFloat(n.Value, 64)
                        if err != nil </span><span class="cov0" title="0">{
                                return condition.NewErrorOperand(err)
                        }</span>
                        <span class="cov8" title="1">return repo.CondFactory.NewFloatOperand(val)</span>
                case token.STRING:<span class="cov8" title="1">
                        unquotedStr, err := strconv.Unquote(n.Value)
                        if err != nil </span><span class="cov0" title="0">{
                                return condition.NewErrorOperand(fmt.Errorf("unable to unquote \"%s\"", n.Value))
                        }</span>
                        <span class="cov8" title="1">return repo.CondFactory.NewStringOperand(unquotedStr)</span>
                }
        case *ast.Ident:<span class="cov8" title="1">
                return repo.CondFactory.NewSelOperand(nil, n.Name)</span>
        case *ast.SelectorExpr:<span class="cov8" title="1">
                x := repo.preprocessAstExpr(n.X, scope)

                switch x.GetKind() </span>{
                case condition.ErrorOperandKind:<span class="cov0" title="0">
                        return x</span>
                case condition.SelOperandKind:<span class="cov8" title="1">
                        return repo.CondFactory.NewSelOperand(
                                x.(*condition.SelOperand).Base,
                                x.(*condition.SelOperand).Selector+"."+n.Sel.Name)</span>
                case condition.IndexOperandKind, condition.AddressOperandKind:<span class="cov8" title="1">
                        return repo.CondFactory.NewSelOperand(x, n.Sel.Name)</span>
                default:<span class="cov0" title="0">
                        panic("should not get here")</span>
                }
        case *ast.IndexExpr:<span class="cov8" title="1">
                x := repo.preprocessAstExpr(n.X, scope)

                i := repo.preprocessAstExpr(n.Index, scope)
                if i.GetKind() == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                        return i
                }</span>

                <span class="cov8" title="1">switch x.GetKind() </span>{
                case condition.ErrorOperandKind:<span class="cov0" title="0">
                        return x</span>
                case condition.SelOperandKind:<span class="cov8" title="1">
                        return repo.CondFactory.NewIndexOperand(
                                repo.CondFactory.NewSelOperand(
                                        x.(*condition.SelOperand).Base,
                                        x.(*condition.SelOperand).Selector+"[]"), i)</span>
                case condition.IndexOperandKind:<span class="cov0" title="0">
                        return repo.CondFactory.NewIndexOperand(repo.CondFactory.NewSelOperand(x, "[]"), i)</span>
                default:<span class="cov0" title="0">
                        panic("should not get here")</span>
                }
        case *ast.ParenExpr:<span class="cov0" title="0">
                return repo.evalAstNode(n.X, scope)</span>
        case *ast.CallExpr:<span class="cov8" title="1">
                funcName := n.Fun.(*ast.Ident).Name
                switch funcName </span>{
                case "date":<span class="cov8" title="1">
                        return repo.convertToType(n, scope, condition.TimeOperandKind)</span>
                case "string":<span class="cov0" title="0">
                        return repo.convertToType(n, scope, condition.StringOperandKind)</span>
                case "int":<span class="cov0" title="0">
                        return repo.convertToType(n, scope, condition.IntOperandKind)</span>
                case "float":<span class="cov0" title="0">
                        return repo.convertToType(n, scope, condition.FloatOperandKind)</span>
                case "regexpMatch":<span class="cov0" title="0">
                        return funcRegexpMatch(repo, n, scope)</span>
                case "hasValue":<span class="cov0" title="0">
                        return funcHasValue(repo, n, scope)</span>
                case "isEqualToAnyWithDate":<span class="cov0" title="0">
                        return funcIsEqualToAnyWithDate(repo, n, scope)</span>
                case "isEqualToAny":<span class="cov0" title="0">
                        return repo.funcIsEqualToAny(n, scope)</span>
                case "forAll":<span class="cov0" title="0">
                        return repo.funcForAll(n, scope)</span>
                case "forSome":<span class="cov8" title="1">
                        return repo.funcForSome(n, scope)</span>
                case "sqrt":<span class="cov0" title="0">
                        argOperand := repo.evalAstNode(n.Args[0], scope)
                        if argOperand.GetKind() == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                                return argOperand
                        }</span>
                        <span class="cov0" title="0">return repo.CondFactory.NewExprOperand(
                                func(event *objectmap.ObjectAttributeMap, frames []interface{}) condition.Operand </span><span class="cov0" title="0">{
                                        arg := argOperand.Evaluate(event, frames)
                                        if arg.GetKind() == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                                                return arg
                                        }</span>
                                        <span class="cov0" title="0">arg = arg.Convert(condition.FloatOperandKind)
                                        return condition.NewFloatOperand(math.Sqrt(float64(arg.(condition.FloatOperand))))</span>
                                }, argOperand, condition.StringOperand(funcName)) // funcName as hash seed to avoid cache collisions
                default:<span class="cov0" title="0">
                        return condition.NewErrorOperand(fmt.Errorf("unsupported function: %s", funcName))</span>
                }
        case *ast.BinaryExpr:<span class="cov8" title="1">
                xOperand := repo.evalAstNode(n.X, scope)
                if xOperand.GetKind() == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                        return xOperand
                }</span>
                <span class="cov8" title="1">yOperand := repo.evalAstNode(n.Y, scope)
                if yOperand.GetKind() == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                        return yOperand
                }</span>

                <span class="cov8" title="1">switch n.Op </span>{
                case token.ADD, token.SUB, token.MUL, token.QUO:<span class="cov8" title="1">
                        return repo.CondFactory.NewExprOperand(
                                func(event *objectmap.ObjectAttributeMap, frames []interface{}) condition.Operand </span><span class="cov8" title="1">{
                                        xVal := xOperand.Evaluate(event, frames).Convert(condition.FloatOperandKind)
                                        if xVal.GetKind() == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                                                return xVal
                                        }</span>
                                        <span class="cov8" title="1">lv := float64(xVal.(condition.FloatOperand))

                                        yVal := yOperand.Evaluate(event, frames).Convert(condition.FloatOperandKind)
                                        if yVal.GetKind() == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                                                return yVal
                                        }</span>
                                        <span class="cov8" title="1">rv := float64(yVal.(condition.FloatOperand))

                                        switch n.Op </span>{
                                        case token.ADD:<span class="cov8" title="1">
                                                return condition.NewFloatOperand(lv + rv)</span>
                                        case token.SUB:<span class="cov0" title="0">
                                                return condition.NewFloatOperand(lv - rv)</span>
                                        case token.MUL:<span class="cov0" title="0">
                                                return condition.NewFloatOperand(lv * rv)</span>
                                        case token.QUO:<span class="cov0" title="0">
                                                return condition.NewFloatOperand(lv / rv)</span>
                                        default:<span class="cov0" title="0">
                                                return condition.NewErrorOperand(fmt.Errorf("unsupported operator: %s", n.Op.String()))</span>
                                        }
                                }, xOperand, yOperand)
                case token.EQL:<span class="cov8" title="1">
                        return repo.genEvalForCompareOperands(condition.CompareEqualOp, xOperand, yOperand)</span>
                case token.LSS:<span class="cov0" title="0">
                        return repo.genEvalForCompareOperands(condition.CompareLessOp, xOperand, yOperand)</span>
                case token.GTR:<span class="cov8" title="1">
                        return repo.genEvalForCompareOperands(condition.CompareGreaterOp, xOperand, yOperand)</span>
                case token.NEQ:<span class="cov8" title="1">
                        return repo.genEvalForCompareOperands(condition.CompareNotEqualOp, xOperand, yOperand)</span>
                case token.LEQ:<span class="cov0" title="0">
                        return repo.genEvalForCompareOperands(condition.CompareLessOrEqualOp, xOperand, yOperand)</span>
                case token.GEQ:<span class="cov8" title="1">
                        return repo.genEvalForCompareOperands(condition.CompareGreaterOrEqualOp, xOperand, yOperand)</span>
                case token.LAND:<span class="cov8" title="1">
                        return repo.genEvalForLogicalOp(token.LAND, xOperand, yOperand)</span>
                case token.LOR:<span class="cov0" title="0">
                        return repo.genEvalForLogicalOp(token.LOR, xOperand, yOperand)</span>
                default:<span class="cov0" title="0">
                        return condition.NewErrorOperand(fmt.Errorf("unsupported operator: %s", n.Op.String()))</span>
                }
        case *ast.UnaryExpr:<span class="cov0" title="0">
                switch n.Op </span>{
                case token.NOT:<span class="cov0" title="0">
                        xOperand := repo.evalAstNode(n.X, scope)
                        if xOperand.GetKind() == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                                return xOperand
                        }</span>
                        <span class="cov0" title="0">return repo.genEvalForCompareOperands(
                                condition.CompareNotEqualOp, xOperand, condition.NewBooleanOperand(true))</span>
                default:<span class="cov0" title="0">
                        return condition.NewErrorOperand(
                                repo.ctx.Errorf("unsupported operator: %s", n.Op.String()))</span>
                }
        }

        <span class="cov0" title="0">return repo.CondFactory.NewErrorOperand(fmt.Errorf("unsupported node type: %T", node))</span>
}

func (repo *CompareCondRepo) convertToType(n *ast.CallExpr, scope *ForEachScope, operandKind condition.OperandKind) condition.Operand <span class="cov8" title="1">{
        if len(n.Args) != 1 </span><span class="cov0" title="0">{
                return condition.NewErrorOperand(fmt.Errorf("wrong number of arguments for float conversion"))
        }</span>
        <span class="cov8" title="1">argOperand := repo.evalAstNode(n.Args[0], scope)
        if argOperand.GetKind() == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                return argOperand
        }</span>
        <span class="cov8" title="1">if argOperand.IsConst() </span><span class="cov8" title="1">{
                return argOperand.Convert(operandKind)
        }</span>
        <span class="cov8" title="1">return repo.CondFactory.NewExprOperand(
                func(event *objectmap.ObjectAttributeMap, frames []interface{}) condition.Operand </span><span class="cov8" title="1">{
                        arg := argOperand.Evaluate(event, frames)
                        if arg.GetKind() == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                                return arg
                        }</span>
                        <span class="cov8" title="1">return arg.Convert(operandKind)</span>
                }, argOperand, condition.IntOperand(operandKind)) // operandKind as hash seed to avoid cache collisions
}

func funcIsEqualToAnyWithDate(repo *CompareCondRepo, n *ast.CallExpr, scope *ForEachScope) condition.Operand <span class="cov8" title="1">{
        if len(n.Args) &lt; 5 </span><span class="cov0" title="0">{
                return condition.NewErrorOperand(fmt.Errorf("wrong number of arguments for isEqualtoAnyWithDate() function"))
        }</span>

        <span class="cov8" title="1">if len(n.Args)%3 != 2 </span><span class="cov0" title="0">{
                return condition.NewErrorOperand(fmt.Errorf("wrong number of arguments for isEqualtoAnyWithDate() function"))
        }</span>

        <span class="cov8" title="1">argOperands := types.MapSlice(n.Args, func(o ast.Expr) condition.Operand </span><span class="cov8" title="1">{ return repo.evalAstNode(o, scope) }</span>)
        <span class="cov8" title="1">firstErrorOperand := types.FindFirstInSlice(
                argOperands, func(o condition.Operand) bool </span><span class="cov8" title="1">{ return o.GetKind() == condition.ErrorOperandKind }</span>)
        <span class="cov8" title="1">if firstErrorOperand != nil </span><span class="cov0" title="0">{
                return condition.NewErrorOperand((*firstErrorOperand).(*condition.ErrorOperand).Err)
        }</span>

        <span class="cov8" title="1">constOperands := types.FilterSlice(argOperands[2:], func(o condition.Operand) bool </span><span class="cov8" title="1">{ return o.IsConst() }</span>)

        <span class="cov8" title="1">if len(constOperands) != len(argOperands)-2 </span><span class="cov0" title="0">{
                // Not all operands in the match list are constants
                return condition.NewErrorOperand(fmt.Errorf("isEqualToAny() only supports constant match list"))
        }</span>

        <span class="cov8" title="1">return repo.evalIsInConstantListWithDateRange(argOperands[0], argOperands[1], argOperands[2:])</span>
}

func funcHasValue(repo *CompareCondRepo, n *ast.CallExpr, scope *ForEachScope) condition.Operand <span class="cov8" title="1">{
        if len(n.Args) != 1 </span><span class="cov0" title="0">{
                return condition.NewErrorOperand(fmt.Errorf("wrong number of arguments for hasValue() function"))
        }</span>
        // In most places we call evalAstNode, but it also calls repo.evalOperandAccess in addition to the calls below.
        // In this case we don't want to call evalAstNode, because we also want to check if we are dealing with
        // addressable operand here.
        <span class="cov8" title="1">argOperand := repo.evalOperandAddress(repo.preprocessAstExpr(n.Args[0], scope), scope)
        if argOperand.GetKind() == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                return argOperand
        }</span>

        <span class="cov8" title="1">if argOperand.IsConst() </span><span class="cov0" title="0">{
                // A constant always exists
                return condition.NewBooleanOperand(true)
        }</span>

        <span class="cov8" title="1">if argOperand.GetKind() != condition.AddressOperandKind </span><span class="cov0" title="0">{
                return condition.NewErrorOperand(fmt.Errorf("argument to hasValue() function must be an addressable expression"))
        }</span>

        // Now that we made sure that we got the AddressOperandKind above we can do the last step and evaluate the value.
        // Normally this would be done for us automatically in
        <span class="cov8" title="1">argOperand = repo.evalOperandAccess(argOperand, scope)
        return repo.CondFactory.NewExprOperand(
                func(event *objectmap.ObjectAttributeMap, frames []interface{}) condition.Operand </span><span class="cov8" title="1">{
                        arg := argOperand.Evaluate(event, frames)
                        kind := arg.GetKind()
                        if kind == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                                return arg
                        }</span>
                        <span class="cov8" title="1">return condition.NewBooleanOperand(kind != condition.NullOperandKind)</span>
                }, argOperand) // operandKind as hash seed to avoid cache collisions
}

func funcRegexpMatch(repo *CompareCondRepo, n *ast.CallExpr, scope *ForEachScope) condition.Operand <span class="cov8" title="1">{
        if len(n.Args) != 2 </span><span class="cov0" title="0">{
                return condition.NewErrorOperand(fmt.Errorf("wrong number of arguments for regexpMatch() function"))
        }</span>
        <span class="cov8" title="1">patternOperand := repo.evalAstNode(n.Args[0], scope)

        if patternOperand.GetKind() == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                return patternOperand
        }</span>

        <span class="cov8" title="1">if !patternOperand.IsConst() </span><span class="cov0" title="0">{
                return condition.NewErrorOperand(
                        fmt.Errorf("the first operand of regexpMatch() must be a constant string pattern"))
        }</span>

        <span class="cov8" title="1">if patternOperand.GetKind() != condition.StringOperandKind </span><span class="cov0" title="0">{
                return condition.NewErrorOperand(
                        fmt.Errorf("the first operand of regexpMatch() must be a constant string pattern"))
        }</span>

        <span class="cov8" title="1">patternString := string(patternOperand.(condition.StringOperand))
        re, err := regexp.Compile(patternString)
        if err != nil </span><span class="cov0" title="0">{
                return condition.NewErrorOperand(
                        fmt.Errorf("invalid pattern:\"%s\" passed to regexpMatch()", patternString))
        }</span>

        <span class="cov8" title="1">argOperand := repo.evalAstNode(n.Args[1], scope)
        if argOperand.GetKind() == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                return argOperand
        }</span>

        <span class="cov8" title="1">return repo.CondFactory.NewExprOperand(
                func(event *objectmap.ObjectAttributeMap, frames []interface{}) condition.Operand </span><span class="cov8" title="1">{
                        arg := argOperand.Evaluate(event, frames)
                        kind := arg.GetKind()
                        if kind == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                                return arg
                        }</span>
                        <span class="cov8" title="1">argString := string(arg.Convert(condition.StringOperandKind).(condition.StringOperand))
                        result := condition.NewBooleanOperand(re.MatchString(argString))
                        return result</span>
                }, argOperand) // operandKind as hash seed to avoid cache collisions
}

func (repo *CompareCondRepo) funcIsEqualToAny(n *ast.CallExpr, scope *ForEachScope) condition.Operand <span class="cov0" title="0">{
        if len(n.Args) &lt; 2 </span><span class="cov0" title="0">{
                return condition.NewErrorOperand(fmt.Errorf("wrong number of arguments for isEqualToAny() function"))
        }</span>

        <span class="cov0" title="0">argOperands := types.MapSlice(n.Args, func(o ast.Expr) condition.Operand </span><span class="cov0" title="0">{ return repo.evalAstNode(o, scope) }</span>)
        <span class="cov0" title="0">firstErrorOperand := types.FindFirstInSlice(
                argOperands, func(o condition.Operand) bool </span><span class="cov0" title="0">{ return o.GetKind() == condition.ErrorOperandKind }</span>)
        <span class="cov0" title="0">if firstErrorOperand != nil </span><span class="cov0" title="0">{
                return *firstErrorOperand
        }</span>

        <span class="cov0" title="0">constOperands := types.FilterSlice(argOperands[1:], func(o condition.Operand) bool </span><span class="cov0" title="0">{ return o.IsConst() }</span>)

        // See if we are comparing against const values
        <span class="cov0" title="0">if argOperands[0].IsConst() </span><span class="cov0" title="0">{
                for _, argOperand := range constOperands </span><span class="cov0" title="0">{
                        if argOperands[0].Equals(argOperand) </span><span class="cov0" title="0">{
                                return condition.NewBooleanOperand(true)
                        }</span>
                }
                <span class="cov0" title="0">if len(constOperands) == len(argOperands)-1 </span><span class="cov0" title="0">{
                        // All operands are constant and do not match
                        return condition.NewBooleanOperand(false)
                }</span>
        }

        // TODO: below is not implemented yet
        <span class="cov0" title="0">argOperand := repo.evalOperandAccess(argOperands[0], scope)
        return repo.CondFactory.NewExprOperand(
                func(event *objectmap.ObjectAttributeMap, frames []interface{}) condition.Operand </span><span class="cov0" title="0">{
                        arg := argOperand.Evaluate(event, frames)
                        kind := arg.GetKind()
                        if kind == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                                return arg
                        }</span>
                        <span class="cov0" title="0">return condition.NewBooleanOperand(kind != condition.NullOperandKind)</span>
                }, argOperand) // operandKind as hash seed to avoid cache collisions
}

func findElementScope(element string, parentScope *ForEachScope) *ForEachScope <span class="cov8" title="1">{
        // ASSUME: rootScope.element == "" and will match $.something path
        for scope := parentScope; scope != nil; scope = scope.ParentScope </span><span class="cov8" title="1">{
                if element == scope.Element || scope.NestingLevel == 0 </span><span class="cov8" title="1">{
                        return scope
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// expandPath will take a path like parent.some.attribute, split it into parent and some.attribute components,
// lookup the parent element in the parent scopes
// It will return:
//   - the ancestor scope defining the referenced element
//   - child path or full path if the ancestor is the root scope
func expandPath(path string, parentScope *ForEachScope) (*ForEachScope, string) <span class="cov8" title="1">{
        // 1. Given a path like $parent.some.attribute, split it into parent and some.attribute components
        parts := strings.SplitN(path, ".", 2)
        // 2. Lookup the parent in the parent scopes and get the nesting NestingLevel of the scope that defines the parent
        scope := findElementScope(parts[0], parentScope)
        if scope.NestingLevel == 0 </span><span class="cov8" title="1">{
                return scope, path
        }</span> else<span class="cov8" title="1"> {
                return scope, parts[1]
        }</span>
}

func getAttributePathAddress(attrPath string, parentScope *ForEachScope) (*objectmap.AttributeAddress, error) <span class="cov8" title="1">{
        pScope, ePath := expandPath(attrPath, parentScope)
        addr, err := pScope.AttrDictRec.AttributePathToAddress(ePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // TODO, should this be coming from the AttributePathToAddress?
        // Also the MatchId is wrong here.  It doesn't break things though, because
        // the nested matchid is not really used
        <span class="cov8" title="1">return &amp;objectmap.AttributeAddress{
                Address:              addr,
                Path:                 ePath,
                ParentParameterIndex: pScope.NestingLevel,
                FullAddress:          pScope.AttrDictRec.AddressToFullAddress(addr)}, nil</span>
}

func (repo *CompareCondRepo) evalAstNode(node ast.Expr, scope *ForEachScope) condition.Operand <span class="cov8" title="1">{
        return repo.evalOperandAccess(repo.evalOperandAddress(repo.preprocessAstExpr(node, scope), scope), scope)
}</span>

func (repo *CompareCondRepo) evalOperandAccess(operand condition.Operand, scope *ForEachScope) condition.Operand <span class="cov8" title="1">{
        if operand.IsConst() </span><span class="cov8" title="1">{
                // This includes error operand
                return operand
        }</span>

        <span class="cov8" title="1">if operand.GetKind() == condition.ExpressionOperandKind </span><span class="cov8" title="1">{
                return operand
        }</span>

        // assert: this is an AddressOperand
        <span class="cov8" title="1">repo.registerCatEvaluatorForAddress(operand.(*condition.AddressOperand).FullAddress, scope.Evaluator)

        return repo.CondFactory.NewExprOperand(
                func(event *objectmap.ObjectAttributeMap, frames []interface{}) condition.Operand </span><span class="cov8" title="1">{
                        address := operand.Evaluate(event, frames)
                        if address.GetKind() == condition.ErrorOperandKind </span><span class="cov8" title="1">{
                                return address
                        }</span>
                        <span class="cov8" title="1">val := objectmap.GetNestedAttributeByAddress(
                                frames[address.(*condition.AddressOperand).ParameterIndex], address.(*condition.AddressOperand).Address)
                        if val == nil </span><span class="cov8" title="1">{
                                return condition.NewNullOperand(address.(*condition.AddressOperand))
                        }</span>
                        <span class="cov8" title="1">return val.(condition.Operand)</span>
                }, operand)
}

func (repo *CompareCondRepo) evalOperandAddress(operand condition.Operand, scope *ForEachScope) condition.Operand <span class="cov8" title="1">{
        switch o := operand.(type) </span>{
        case *condition.AttributeOperand:<span class="cov0" title="0">
                attrAddress, err := getAttributePathAddress(operand.(*condition.AttributeOperand).AttributePath, scope)
                if err != nil </span><span class="cov0" title="0">{
                        return repo.CondFactory.NewErrorOperand(err)
                }</span> else<span class="cov0" title="0"> {
                        return repo.CondFactory.NewAddressOperand(
                                attrAddress.Address,
                                attrAddress.FullAddress,
                                attrAddress.ParentParameterIndex,
                                nil)
                }</span>
        case *condition.SelOperand:<span class="cov8" title="1">
                if o.Base == nil </span><span class="cov8" title="1">{
                        pScope, ePath := expandPath(o.Selector, scope)
                        addr, err := pScope.AttrDictRec.AttributePathToAddress(ePath)
                        if err != nil </span><span class="cov0" title="0">{
                                return condition.NewErrorOperand(err)
                        }</span>
                        <span class="cov8" title="1">return repo.CondFactory.NewAddressOperand(addr, pScope.AttrDictRec.AddressToFullAddress(addr), pScope.NestingLevel, nil)</span>
                }

                <span class="cov8" title="1">base := repo.evalOperandAddress(o.Base, scope)
                if base.GetKind() == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                        return base
                }</span>
                <span class="cov8" title="1">switch b := base.(type) </span>{
                case *condition.AddressOperand:<span class="cov8" title="1">
                        dictRec := repo.ObjectAttributeMapper.RootDictRec.AddressToDictionaryRec(b.Address)
                        addr, err := dictRec.AttributePathToAddress(o.Selector)
                        if err != nil </span><span class="cov0" title="0">{
                                return condition.NewErrorOperand(err)
                        }</span>
                        <span class="cov8" title="1">attrAddress := objectmap.ExtendAddress(b.Address, addr...)
                        fullAddress := objectmap.ExtendAddress(b.FullAddress, addr...)
                        if b.ExprOperand == nil </span><span class="cov8" title="1">{
                                // Base is a simple address with no dynamic computation.  Use it as immutable.
                                return repo.CondFactory.NewAddressOperand(attrAddress, fullAddress, b.ParameterIndex, nil)
                        }</span> else<span class="cov8" title="1"> {
                                // Base address has to be computed and so does the selector
                                return repo.CondFactory.NewAddressOperand(
                                        attrAddress,
                                        fullAddress,
                                        b.ParameterIndex,
                                        repo.CondFactory.NewExprOperand(
                                                func(event *objectmap.ObjectAttributeMap, frames []interface{}) condition.Operand </span><span class="cov8" title="1">{
                                                        baseAddress := b.Evaluate(event, frames)
                                                        switch baseAddress.GetKind() </span>{
                                                        case condition.ErrorOperandKind:<span class="cov8" title="1">
                                                                return baseAddress</span>
                                                        case condition.AddressOperandKind:<span class="cov8" title="1">
                                                                attrAddress = append(baseAddress.(*condition.AddressOperand).Address, addr...)
                                                                fullAddress = append(baseAddress.(*condition.AddressOperand).FullAddress, addr...)
                                                                return condition.NewAddressOperand(attrAddress, fullAddress, b.ParameterIndex, nil)</span>
                                                        }
                                                        <span class="cov0" title="0">panic("should not get here")</span>
                                                        //val := objectmap.GetNestedAttributeByAddress(frames[0], attrAddress)
                                                        //return val.(condition.Operand)
                                                }, operand))
                        }
                default:<span class="cov0" title="0">
                        panic("should not get here")</span>
                }
        case *condition.IndexOperand:<span class="cov8" title="1">
                if o.Base == nil </span><span class="cov0" title="0">{
                        addr, err := repo.ObjectAttributeMapper.RootDictRec.AttributePathToAddress("")
                        if err != nil </span><span class="cov0" title="0">{
                                return condition.NewErrorOperand(err)
                        }</span>
                        <span class="cov0" title="0">indexOperand := repo.evalOperandAddress(o.IndexExpr, scope)
                        if indexOperand.GetKind() == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                                return indexOperand
                        }</span>
                        <span class="cov0" title="0">if indexOperand.IsConst() </span><span class="cov0" title="0">{
                                io := indexOperand.Convert(condition.IntOperandKind)
                                if io.GetKind() == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                                        return io
                                }</span>
                                <span class="cov0" title="0">address := objectmap.ExtendAddress(addr, int(io.(condition.IntOperand)))
                                return repo.CondFactory.NewAddressOperand(address, address, 0, nil)</span>
                        } else<span class="cov0" title="0"> {
                                // Use -1 for the index to indicate that it is not known until evaluation time
                                staticAddress := objectmap.ExtendAddress(addr, -1)
                                return repo.CondFactory.NewAddressOperand(
                                        staticAddress,
                                        staticAddress,
                                        0,
                                        repo.CondFactory.NewExprOperand(
                                                func(event *objectmap.ObjectAttributeMap, frames []interface{}) condition.Operand </span><span class="cov0" title="0">{
                                                        io := indexOperand.Evaluate(event, frames).Convert(condition.IntOperandKind)
                                                        if io.GetKind() == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                                                                return io
                                                        }</span>
                                                        <span class="cov0" title="0">address := objectmap.ExtendAddress(addr, int(io.(condition.IntOperand)))
                                                        return condition.NewAddressOperand(address, address, 0, nil)</span>
                                                }, operand))
                        }
                } else<span class="cov8" title="1"> {
                        baseOperand := repo.evalOperandAddress(o.Base, scope)
                        if baseOperand.GetKind() == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                                return baseOperand
                        }</span>
                        <span class="cov8" title="1">indexOperand := repo.evalOperandAddress(o.IndexExpr, scope)
                        if indexOperand.GetKind() == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                                return indexOperand
                        }</span>
                        <span class="cov8" title="1">if baseOperand.(*condition.AddressOperand).ExprOperand == nil &amp;&amp; indexOperand.IsConst() </span><span class="cov8" title="1">{
                                io := indexOperand.Convert(condition.IntOperandKind)
                                if io.GetKind() == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                                        return io
                                }</span>
                                <span class="cov8" title="1">address := objectmap.ExtendAddress(baseOperand.(*condition.AddressOperand).Address, int(io.(condition.IntOperand)))
                                fullAddress := objectmap.ExtendAddress(baseOperand.(*condition.AddressOperand).FullAddress, int(io.(condition.IntOperand)))
                                return repo.CondFactory.NewAddressOperand(address, fullAddress, baseOperand.(*condition.AddressOperand).ParameterIndex, nil)</span>
                        } else<span class="cov8" title="1"> {
                                // Use -1 for the index to indicate that it is not known until evaluation time
                                staticAddress := objectmap.ExtendAddress(baseOperand.(*condition.AddressOperand).Address, -1)
                                staticFullAddress := objectmap.ExtendAddress(baseOperand.(*condition.AddressOperand).FullAddress, -1)
                                ioAccess := repo.evalOperandAccess(indexOperand, scope)
                                return repo.CondFactory.NewAddressOperand(
                                        staticAddress,
                                        staticFullAddress,
                                        baseOperand.(*condition.AddressOperand).ParameterIndex,
                                        repo.CondFactory.NewExprOperand(func(event *objectmap.ObjectAttributeMap, frames []interface{}) condition.Operand </span><span class="cov8" title="1">{
                                                bo := baseOperand.Evaluate(event, frames)
                                                if bo.GetKind() == condition.ErrorOperandKind </span><span class="cov0" title="0">{
                                                        return bo
                                                }</span>
                                                <span class="cov8" title="1">io := ioAccess.Evaluate(event, frames).Convert(condition.IntOperandKind)
                                                if io.GetKind() == condition.ErrorOperandKind </span><span class="cov8" title="1">{
                                                        return io
                                                }</span>
                                                <span class="cov8" title="1">iov := int(io.(condition.IntOperand))
                                                bov := bo.(*condition.AddressOperand)
                                                address := objectmap.ExtendAddress(bov.Address, iov)
                                                // fullAddress is not strictly needed in this case.  Use nil instead if you want to optimize.
                                                fullAddress := objectmap.ExtendAddress(bov.FullAddress, iov)
                                                return condition.NewAddressOperand(address, fullAddress, bov.ParameterIndex, nil)</span>
                                        }, operand))
                        }
                }
        default:<span class="cov8" title="1">
                return operand</span>
        }
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package engine

import (
        "github.com/atlasgurus/rulestone/condition"
        "github.com/cloudflare/ahocorasick"
)

func contains(text string, patterns []string) []string <span class="cov0" title="0">{
        machine := ahocorasick.NewStringMatcher(patterns)
        hits := machine.Match([]byte(text))

        // Extracting the matched patterns from the hits.
        matchedPatterns := make([]string, len(hits))
        for i, hit := range hits </span><span class="cov0" title="0">{
                matchedPatterns[i] = patterns[hit]
        }</span>

        <span class="cov0" title="0">return matchedPatterns</span>
}

type StringMatcher struct {
        machine    *ahocorasick.Matcher
        patterns   []string
        categories [][]condition.Operand
        matchMap   map[string]int
}

func NewStringMatcher() *StringMatcher <span class="cov8" title="1">{
        return &amp;StringMatcher{matchMap: make(map[string]int)}
}</span>

func (sm *StringMatcher) AddPattern(pattern string, category condition.Operand) <span class="cov8" title="1">{
        if index, ok := sm.matchMap[pattern]; !ok </span><span class="cov8" title="1">{
                sm.matchMap[pattern] = len(sm.patterns)
                sm.patterns = append(sm.patterns, pattern)
                sm.categories = append(sm.categories, []condition.Operand{category})
        }</span> else<span class="cov0" title="0"> {
                sm.categories[index] = append(sm.categories[index], category)
        }</span>
}

func (sm *StringMatcher) Build() <span class="cov8" title="1">{
        if sm.machine != nil </span><span class="cov0" title="0">{
                panic("StringMatcher already built")</span>
        }
        <span class="cov8" title="1">sm.machine = ahocorasick.NewStringMatcher(sm.patterns)</span>
}

func (sm *StringMatcher) Match(text string) []condition.Operand <span class="cov8" title="1">{
        if sm.machine == nil </span><span class="cov0" title="0">{
                panic("StringMatcher not built")</span>
        }
        <span class="cov8" title="1">hits := sm.machine.Match([]byte(text))

        matchedCategories := make([]condition.Operand, 0)
        for _, hit := range hits </span><span class="cov8" title="1">{
                matchedCategories = append(matchedCategories, sm.categories[hit]...)
        }</span>

        <span class="cov8" title="1">return matchedCategories</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package immutable

import (
        "bytes"
        "crypto/sha256"
        "encoding/binary"
        "github.com/dchest/siphash"
        "github.com/zyedidia/generic/hashset"
)

const fastHash = false

type SetElement interface {
        GetHash() uint64
        Equals(element SetElement) bool
}

type Set[K SetElement] struct {
        set  *hashset.Set[K]
        hash uint64
}

func Rehash(v uint64) uint64 <span class="cov8" title="1">{
        return HashInt(v)
}</span>

func (s Set[K]) GetHash() uint64 <span class="cov8" title="1">{
        return s.hash
}</span>

func (s Set[K]) Equals(element SetElement) bool <span class="cov8" title="1">{
        hashEquals := s.GetHash() == element.GetHash()
        if hashEquals </span><span class="cov8" title="1">{
                // TODO still need to compare values, unless cryptographic hash is used
                return hashEquals
        }</span> else<span class="cov8" title="1"> {
                return false
        }</span>
}

func (s Set[K]) Has(val K) bool <span class="cov8" title="1">{
        return s.set.Has(val)
}</span>

func (s Set[K]) Union(a Set[K]) Set[K] <span class="cov8" title="1">{
        result := s.set.Copy()
        a.set.Each(func(key K) </span><span class="cov8" title="1">{
                result.Put(key)
        }</span>)
        <span class="cov8" title="1">hash := uint64(0)
        result.Each(func(key K) </span><span class="cov8" title="1">{
                hash ^= Rehash(key.GetHash())
        }</span>)
        <span class="cov8" title="1">return Set[K]{result, hash}</span>
}

func (s Set[K]) Difference(a Set[K]) Set[K] <span class="cov0" title="0">{
        result := s.set.Copy()
        a.set.Each(func(key K) </span><span class="cov0" title="0">{
                result.Remove(key)
        }</span>)
        <span class="cov0" title="0">hash := uint64(0)
        result.Each(func(key K) </span><span class="cov0" title="0">{
                hash ^= Rehash(key.GetHash())
        }</span>)
        <span class="cov0" title="0">return Set[K]{result, hash}</span>
}

func (s Set[K]) IsSuperset(a Set[K]) bool <span class="cov0" title="0">{
        result := true
        a.set.Each(func(key K) </span><span class="cov0" title="0">{
                if result &amp;&amp; !s.Has(key) </span><span class="cov0" title="0">{
                        result = false
                }</span>
        })
        <span class="cov0" title="0">return result</span>
}

func (s Set[K]) Each(fn func(key K)) <span class="cov8" title="1">{
        s.set.Each(fn)
}</span>

func (s Set[K]) Size() int <span class="cov8" title="1">{
        return s.set.Size()
}</span>

func (s Set[K]) ToSlice() []K <span class="cov8" title="1">{
        var result []K
        s.set.Each(func(key K) </span><span class="cov8" title="1">{
                result = append(result, key)
        }</span>)
        <span class="cov8" title="1">return result</span>
}

// Of returns a new hashset initialized with the given 'vals'
func Of[K SetElement](vals ...K) *Set[K] <span class="cov8" title="1">{
        var hash uint64 = 0
        set := hashset.Of[K](0, func(a, b K) bool </span><span class="cov8" title="1">{ return a.Equals(b) }</span>, K.GetHash, vals...)

        <span class="cov8" title="1">set.Each(func(v K) </span><span class="cov8" title="1">{
                hash ^= Rehash(v.GetHash())
        }</span>)

        <span class="cov8" title="1">return &amp;Set[K]{set: set, hash: hash}</span>
}

func FromHashSet[K SetElement](set *hashset.Set[K]) *Set[K] <span class="cov8" title="1">{
        var hash uint64 = 0

        set.Each(func(v K) </span><span class="cov8" title="1">{
                hash ^= Rehash(v.GetHash())
        }</span>)

        <span class="cov8" title="1">return &amp;Set[K]{set: set, hash: hash}</span>
}

func (s Set[K]) ToHashSet() hashset.Set[K] <span class="cov8" title="1">{
        return *hashset.Of[K](0, func(a, b K) bool </span><span class="cov8" title="1">{ return a.Equals(b) }</span>, K.GetHash, s.ToSlice()...)
}

func hashIntFast(v any) uint64 <span class="cov0" title="0">{
        var buf bytes.Buffer
        err := binary.Write(&amp;buf, binary.LittleEndian, v)
        if err != nil </span><span class="cov0" title="0">{
                panic("Failed byte encoding of Int")</span>
        }
        <span class="cov0" title="0">return siphash.Hash(0, 0, buf.Bytes())</span>
}

func hashIntCrypto(v any) uint64 <span class="cov8" title="1">{
        var buf bytes.Buffer
        err := binary.Write(&amp;buf, binary.LittleEndian, v)
        if err != nil </span><span class="cov0" title="0">{
                panic("Failed byte encoding of Int")</span>
        }
        <span class="cov8" title="1">x := sha256.Sum256(buf.Bytes())
        return binary.LittleEndian.Uint64(x[0:8])</span>
}

func HashInt(v any) uint64 <span class="cov8" title="1">{
        if fastHash </span><span class="cov0" title="0">{
                return hashIntFast(v)
        }</span> else<span class="cov8" title="1"> {
                return hashIntCrypto(v)
        }</span>
}

func ArrayIntToInt64(v []int) []int64 <span class="cov8" title="1">{
        result := make([]int64, len(v))

        for i, v := range v </span><span class="cov8" title="1">{
                result[i] = int64(v)
        }</span>
        <span class="cov8" title="1">return result</span>
}

func HashIntArray(v []int) uint64 <span class="cov8" title="1">{
        return HashInt(ArrayIntToInt64(v))
}</span>

func hashStringFast(v string) uint64 <span class="cov0" title="0">{
        var buf bytes.Buffer
        buf.WriteString(v)
        return siphash.Hash(0, 0, buf.Bytes())
}</span>

func hashStringCrypto(v string) uint64 <span class="cov8" title="1">{
        var buf bytes.Buffer
        buf.WriteString(v)
        x := sha256.Sum256(buf.Bytes())
        return binary.LittleEndian.Uint64(x[0:8])
}</span>

func HashString(v string) uint64 <span class="cov8" title="1">{
        if fastHash </span><span class="cov0" title="0">{
                return hashStringFast(v)
        }</span> else<span class="cov8" title="1"> {
                return hashStringCrypto(v)
        }</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package objectmap

import (
        "fmt"
        "github.com/atlasgurus/rulestone/types"
        "reflect"
        "strconv"
        "strings"
        "sync"
)

type AttrDictionaryRec struct {
        mapIndex      int
        dict          map[string]*AttrDictionaryRec
        dictIndex     []*AttrDictionaryRec
        attribute     string
        numAttributes int
        mapper        *ObjectAttributeMapper
        path          string
        Address       []int
}

// ObjectAttributeMapper object indexes object field names used in general filters.
// It then uses these indexes to create EventAttributeMap object representation that
// only store the fields referenced by the filters.  EventAttributeMap also allows
// fast access to these fields when evaluating filters.
type ObjectAttributeMapper struct {
        RootDictRec *AttrDictionaryRec
        Ctx         *types.AppContext
        Config      MapperConfig
        objectPool  *sync.Pool
        //mu          sync.Mutex
        // Global list to keep track of all allocated *ObjectAttributeMap
        objectList []*ObjectAttributeMap
}

type MapperConfig interface {
        MapScalar(interface{}) interface{}
        GetAppCtx() *types.AppContext
}

func NewObjectAttributeMapper(config MapperConfig) *ObjectAttributeMapper <span class="cov8" title="1">{
        result := ObjectAttributeMapper{Config: config, Ctx: config.GetAppCtx()}
        result.RootDictRec = &amp;AttrDictionaryRec{dict: make(map[string]*AttrDictionaryRec), mapper: &amp;result}
        // Global pool of *ObjectAttributeMap
        result.objectPool = &amp;sync.Pool{
                New: func() interface{} </span><span class="cov8" title="1">{
                        return &amp;ObjectAttributeMap{
                                Values: make([]interface{}, 0, 100), // Assume a default capacity of 100
                        }
                }</span>,
        }
        <span class="cov8" title="1">return &amp;result</span>
}

type ObjectAttributeMap struct {
        DictRec *AttrDictionaryRec
        Values  []interface{}
}

type PathSegment struct {
        segment    string
        quantifier string
        index      int
}

func (mapper *ObjectAttributeMapper) newPathSegment(segment string, quantifier string, isArray bool) (*PathSegment, error) <span class="cov8" title="1">{
        switch quantifier </span>{
        case "*", "+":<span class="cov0" title="0">
                return &amp;PathSegment{segment: segment, quantifier: quantifier, index: 0}, nil</span>
        case "":<span class="cov8" title="1">
                if isArray </span><span class="cov8" title="1">{
                        // ARRAY_ELEMENT issue
                        return &amp;PathSegment{segment: segment, quantifier: quantifier, index: -2}, nil
                        //return nil, mapper.Ctx.Errorf("empty quantifier or mapIndex is not allowed %s", attribute)
                }</span> else<span class="cov8" title="1"> {
                        return &amp;PathSegment{segment: segment, quantifier: quantifier, index: -1}, nil
                }</span>
        default:<span class="cov8" title="1">
                if isArray </span><span class="cov8" title="1">{
                        index, err := strconv.Atoi(quantifier)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov8" title="1"> if index &lt; 0 </span><span class="cov0" title="0">{
                                return nil, mapper.Ctx.Errorf("invalid mapIndex %s[%d]", segment, index)
                        }</span> else<span class="cov8" title="1"> {
                                return &amp;PathSegment{segment: segment, quantifier: "", index: index}, nil
                        }</span>
                } else<span class="cov0" title="0"> {
                        return &amp;PathSegment{segment: segment, quantifier: "", index: -1}, nil
                }</span>
        }
}

func (mapper *ObjectAttributeMapper) splitSegments(path string) ([]*PathSegment, error) <span class="cov8" title="1">{
        if path == "" </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">var result []*PathSegment
        var array []string
        p1 := strings.Split(path, "[")

        for _, v1 := range p1 </span><span class="cov8" title="1">{
                p2 := strings.Split(v1, "]")
                for _, v2 := range p2 </span><span class="cov8" title="1">{
                        array = append(array, v2)
                }</span>
        }

        <span class="cov8" title="1">for i := 0; i &lt; len(array); i += 2 </span><span class="cov8" title="1">{
                quantifier := ""
                isArray := i+1 &lt; len(array)
                attr := array[i]
                if strings.HasPrefix(attr, ".") </span><span class="cov8" title="1">{
                        attr = attr[1:]
                }</span>
                <span class="cov8" title="1">if isArray </span><span class="cov8" title="1">{
                        quantifier = array[i+1]
                        attr += "[]"
                }</span>

                // Make sure to record "" attribute after foo[0], but not the one after foo[]
                // foo[] designates the whole array under foo, while foo[0] designates one element named ""
                // while foo[0].fred designates another element named "fred"
                <span class="cov8" title="1">if attr != "" || !strings.HasSuffix(path, "[]") </span><span class="cov8" title="1">{
                        segment, err := mapper.newPathSegment(attr, quantifier, isArray)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">result = append(result, segment)</span>
                }
        }
        <span class="cov8" title="1">return result, nil</span>
}

func (attrMap *ObjectAttributeMap) GetAttribute(attrPath string) (interface{}, error) <span class="cov8" title="1">{
        attrAddress, err := attrMap.DictRec.AttributePathToAddress(attrPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return attrMap.GetAttributeByAddress(attrAddress, attrMap.Values)</span>
}

// AttributeAddress (AA) is an array of integer Values, where the Values are following alternating pattern
// of AttributeIndex(ATI) and ArrayIndex(ARI):  ATI,ARI,ATI,...
// ATI references a specific element in ObjectAttributeMap.Values, while ARI &gt;= 0 mapIndex a nested array element.
// Given "oam ObjectAttributeMap" and "aa AttributeAddress", the attribute may be accessed as follows:
// oam.Values[aa[0]][aa[1]][aa[2]]...
// Case when ARI &lt; 0 denote a quantifier, -1 =&gt; some, -2 =&gt; all.
// The quantifier cases produce an iterator and can not be resolved to a single attribute value.

type AttributeAddress struct {
        Address []int

        // Keep the original Path string around in case we need to issue an error message
        Path string

        // ParentParameterIndex: index into the parentParameter array pointing to the parent Address value
        // The attribute Address is a concatenation of this value and the Address above
        ParentParameterIndex int

        // FullAddress is used for matching an attribute Address with the filters that use it.
        // It may not have the actual values of array indexes when used inside "for each" loops.
        FullAddress []int
}

// AttributePathToAddress
/*
AttributePathToAddress indexes a leaf attribute name for fast lookup and efficient object representation.
LeafAttribute here denotes an attribute that is either a scalar value or an array, but not a struct.
Attributes that point to nested objects are registered together with the nested objects' attributes
using flattened dotted notation.  For example, consider the following Json structure:

{
  "person": {
    "name": "John",
    "age": 25,
    "children": [
      {
        "name": "Jane",
        "age": 3
      },
      {
        "name": "Jim",
        "age": 1
      }
    ]
  }
}

Assuming that all the structure's attributes are referenced, it will be mapped to the following attributes:
   "person.name"
   "person.age"
   "person.children[]"
Note that "person" is not mapped as it is not a leaf attribute.
Neither is "person.children.name" mapped, as we stop at the first array attribute, using [] suffix to indicate
that the value is an array and not a scalar.
*/
func (dictRec *AttrDictionaryRec) AttributePathToAddress(attrPath string) ([]int, error) <span class="cov8" title="1">{
        var result []int
        segments, err := dictRec.mapper.splitSegments(attrPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">curDictRec := dictRec
        for _, s := range segments </span><span class="cov8" title="1">{
                attr := s.segment
                nextDictRec, ok := curDictRec.dict[attr]
                if !ok || nextDictRec.mapIndex == -1 </span><span class="cov8" title="1">{
                        // We have not seen this segment yet. Register it.

                        // Register empty root attribute to simplify matching logic
                        // mapIndex = -1 signifies a non leaf attribute that doesn't have a value stored for it.
                        curDictRec.dict[""] = &amp;AttrDictionaryRec{mapIndex: -1}
                        parts := strings.Split(attr, ".")
                        for i := range parts[:len(parts)-1] </span><span class="cov8" title="1">{
                                if strings.HasSuffix(parts[i], "[]") </span><span class="cov0" title="0">{
                                        panic("Should not get here?")</span>
                                        //break
                                } else<span class="cov8" title="1"> {
                                        // Register empty root attribute to simplify matching logic
                                        // mapIndex = -1 signifies a non leaf attribute that doesn't have a value stored for it.
                                        parentAttr := strings.Join(parts[0:i+1], ".")
                                        if _, ok := curDictRec.dict[parentAttr]; !ok </span><span class="cov8" title="1">{
                                                curDictRec.dict[strings.Join(parts[0:i+1], ".")] = &amp;AttrDictionaryRec{mapIndex: -1}
                                        }</span>
                                }
                        }

                        <span class="cov8" title="1">var newDictRecAddr []int
                        if len(curDictRec.Address) &gt; 0 </span><span class="cov8" title="1">{
                                newDictRecAddr = ExtendAddress(curDictRec.Address, -1, curDictRec.numAttributes)
                        }</span> else<span class="cov8" title="1"> {
                                newDictRecAddr = []int{curDictRec.numAttributes}
                        }</span>

                        <span class="cov8" title="1">var newDictRecPath string
                        if curDictRec.path == "" </span><span class="cov8" title="1">{
                                newDictRecPath = attr
                        }</span> else<span class="cov8" title="1"> {
                                newDictRecPath = curDictRec.path + "." + attr
                        }</span>
                        <span class="cov8" title="1">if s.index != -1 </span><span class="cov8" title="1">{
                                nextDictRec = &amp;AttrDictionaryRec{
                                        mapIndex:  curDictRec.numAttributes,
                                        dict:      make(map[string]*AttrDictionaryRec),
                                        attribute: attr,
                                        path:      newDictRecPath,
                                        Address:   newDictRecAddr}
                                curDictRec.dict[attr] = nextDictRec
                                curDictRec.dictIndex = append(curDictRec.dictIndex, nextDictRec)
                                curDictRec.numAttributes++
                                // ARRAY_ELEMENT issue
                                //} else if attr != "" {
                        }</span> else<span class="cov8" title="1"> {
                                nextDictRec =
                                        &amp;AttrDictionaryRec{
                                                mapIndex:  curDictRec.numAttributes,
                                                attribute: attr,
                                                path:      newDictRecPath,
                                                Address:   newDictRecAddr} // We do not need to save address for scalars
                                curDictRec.dict[attr] = nextDictRec
                                curDictRec.dictIndex = append(curDictRec.dictIndex, nextDictRec)
                                curDictRec.numAttributes++
                        }</span>
                }

                <span class="cov8" title="1">curDictRec = nextDictRec

                // Now generate the Address
                result = append(result, curDictRec.mapIndex)
                if s.index &gt;= 0 </span><span class="cov8" title="1">{
                        // this is an array
                        if s.quantifier == "" </span><span class="cov8" title="1">{
                                result = append(result, s.index)
                        }</span> else<span class="cov0" title="0"> if s.quantifier == "+" </span><span class="cov0" title="0">{
                                result = append(result, -2)
                        }</span> else<span class="cov0" title="0"> if s.quantifier == "*" </span><span class="cov0" title="0">{
                                result = append(result, -1)
                        }</span>
                }
        }
        <span class="cov8" title="1">return result, nil</span>
}

func (dictRec *AttrDictionaryRec) AddressToDictionaryRec(address []int) *AttrDictionaryRec <span class="cov8" title="1">{
        result := dictRec
        for i := 0; i &lt; len(address); i += 2 </span><span class="cov8" title="1">{
                result = result.dictIndex[address[i]]
        }</span>
        <span class="cov8" title="1">return result</span>
}

func (dictRec *AttrDictionaryRec) AddressToFullPath(address []int) string <span class="cov8" title="1">{
        dr := dictRec
        result := dictRec.path
        for i := 0; i &lt; len(address); i += 2 </span><span class="cov8" title="1">{
                s := address[i]
                if result == "" </span><span class="cov8" title="1">{
                        result = dr.dictIndex[s].attribute
                }</span> else<span class="cov8" title="1"> {
                        result = result + "." + dr.dictIndex[s].attribute
                }</span>
                <span class="cov8" title="1">if i+1 &lt; len(address) </span><span class="cov8" title="1">{
                        result = result[0:len(result)-2] + fmt.Sprintf("[%d]", address[i+1])
                }</span>
                <span class="cov8" title="1">dr = dr.dictIndex[s]</span>
        }
        <span class="cov8" title="1">return result</span>
}

func (dictRec *AttrDictionaryRec) AddressToFullAddress(address []int) []int <span class="cov8" title="1">{
        if len(dictRec.Address) &gt; 0 </span><span class="cov8" title="1">{
                result := make([]int, 0, len(address)+len(dictRec.Address)+1)
                result = append(result, dictRec.Address...)
                result = append(result, -1)
                result = append(result, address...)
                return result
        }</span> else<span class="cov8" title="1"> {
                return address
        }</span>
}

func ExtendAddress(address []int, index ...int) []int <span class="cov8" title="1">{
        result := make([]int, 0, len(address)+len(index))
        result = append(result, address...)
        result = append(result, index...)
        return result
}</span>

func AddressMatchKey(address []int) string <span class="cov8" title="1">{
        result := ""
        for i := 0; i &lt; len(address); i += 2 </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov8" title="1">{
                        result = result + "." + fmt.Sprintf("%d", address[i])
                }</span> else<span class="cov8" title="1"> {
                        result = fmt.Sprintf("%d", address[i])
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

func GetNestedAttributeByAddress(
        v interface{}, attrAddress []int) interface{} <span class="cov8" title="1">{
        for _, s := range attrAddress </span><span class="cov8" title="1">{
                switch vv := v.(type) </span>{
                case []interface{}:<span class="cov8" title="1">
                        if s &lt; 0 </span><span class="cov0" title="0">{
                                panic("should not happen")</span>
                        }
                        <span class="cov8" title="1">if s &lt; len(vv) </span><span class="cov8" title="1">{
                                v = vv[s]
                        }</span> else<span class="cov8" title="1"> {
                                // TODO: may need to log a warning here
                                return nil
                        }</span>
                case map[string]interface{}:<span class="cov0" title="0">
                        panic("should not happen")</span>
                default:<span class="cov0" title="0">
                        // The caller should be able to tell if this is a nil value or no value
                        // as long as we map all scalars to Operand interface types
                        return nil</span>
                }
        }
        <span class="cov8" title="1">return v</span>
}

func (attrMap *ObjectAttributeMap) GetAttributeByAddress(attrAddress []int, frame interface{}) (interface{}, error) <span class="cov8" title="1">{
        result := GetNestedAttributeByAddress(frame, attrAddress)
        if result == nil </span><span class="cov0" title="0">{
                return nil, attrMap.DictRec.mapper.Ctx.Errorf(
                        "attribute %s not available", attrMap.DictRec.AddressToFullPath(attrAddress))
        }</span> else<span class="cov8" title="1"> {
                return result, nil
        }</span>
}

func (mapper *ObjectAttributeMapper) NewObjectAttributeMap() *ObjectAttributeMap <span class="cov8" title="1">{
        obj := mapper.objectPool.Get().(*ObjectAttributeMap)
        obj.DictRec = mapper.RootDictRec
        if cap(obj.Values) &lt; mapper.RootDictRec.numAttributes </span><span class="cov0" title="0">{
                obj.Values = make([]interface{}, mapper.RootDictRec.numAttributes)
        }</span> else<span class="cov8" title="1"> {
                obj.Values = obj.Values[:0]                             // Clear the slice
                for i := 0; i &lt; mapper.RootDictRec.numAttributes; i++ </span><span class="cov8" title="1">{ // Resize the slice
                        obj.Values = append(obj.Values, nil)
                }</span>
        }

        // Add the newly created object to the global list
        //mapper.mu.Lock()
        <span class="cov8" title="1">mapper.objectList = append(mapper.objectList, obj)
        //mapper.mu.Unlock()

        return obj</span>
}

func (mapper *ObjectAttributeMapper) FreeObjects() <span class="cov8" title="1">{
        // Return all allocated objects to the pool
        //mapper.mu.Lock()
        for _, obj := range mapper.objectList </span><span class="cov8" title="1">{
                mapper.objectPool.Put(obj)
        }</span>
        // Clear the global list
        <span class="cov8" title="1">mapper.objectList = nil</span>
        //mapper.mu.Unlock()
}

func (mapper *ObjectAttributeMapper) buildObjectMap(
        path string, v interface{}, values []interface{}, dictRec *AttrDictionaryRec, attrCallback func([]int), address []int) <span class="cov8" title="1">{
        kind := reflect.ValueOf(v).Kind()
        switch kind </span>{
        case reflect.Map:<span class="cov8" title="1">
                _, ok := dictRec.dict[path]
                if ok </span><span class="cov8" title="1">{
                        if strings.HasSuffix(path, "[]") </span><span class="cov0" title="0">{
                                panic("not sure if this can happen")</span>
                        } else<span class="cov8" title="1"> {
                                // Add separator only if Path is not empty
                                if path != "" </span><span class="cov8" title="1">{
                                        path += "."
                                }</span>
                                <span class="cov8" title="1">for key, value := range v.(map[string]interface{}) </span><span class="cov8" title="1">{
                                        mapper.buildObjectMap(path+key, value, values, dictRec, attrCallback, address)
                                }</span>
                        }
                }
        case reflect.Slice:<span class="cov8" title="1">
                attrDictRec, ok := dictRec.dict[path+"[]"]
                if ok </span><span class="cov8" title="1">{
                        newAddress := append(address, attrDictRec.mapIndex, 0)
                        for i, elem := range v.([]interface{}) </span><span class="cov8" title="1">{
                                newAddress[len(newAddress)-1] = i
                                newValues := make([]interface{}, attrDictRec.numAttributes)
                                oldList := values[attrDictRec.mapIndex]
                                if oldList == nil </span><span class="cov8" title="1">{
                                        values[attrDictRec.mapIndex] = []interface{}{newValues}
                                }</span> else<span class="cov8" title="1"> {
                                        values[attrDictRec.mapIndex] = append(oldList.([]interface{}), newValues)
                                }</span>
                                <span class="cov8" title="1">mapper.buildObjectMap("", elem, newValues, attrDictRec, attrCallback, newAddress)</span>
                        }
                        <span class="cov8" title="1">attrCallback(newAddress)</span>
                }
        case reflect.Int, reflect.Int64, reflect.String, reflect.Float64, reflect.Bool, reflect.Invalid:<span class="cov8" title="1">
                attrDictRec, ok := dictRec.dict[path]
                if ok &amp;&amp; attrDictRec.mapIndex != -1 </span><span class="cov8" title="1">{
                        newAddress := append(address, attrDictRec.mapIndex)
                        values[attrDictRec.mapIndex] = mapper.Config.MapScalar(v)
                        attrCallback(newAddress)
                }</span>
        default:<span class="cov0" title="0">
                panic("Should not get here")</span>
        }
}

func (mapper *ObjectAttributeMapper) MapObject(v interface{}, attrCallback func([]int)) *ObjectAttributeMap <span class="cov8" title="1">{
        address := make([]int, 0, 20)
        result := mapper.NewObjectAttributeMap()
        mapper.buildObjectMap("", v, result.Values, result.DictRec, attrCallback, address)
        return result
}</span>

func (attrMap *ObjectAttributeMap) GetNumElementsAtAddress(address *AttributeAddress, frames []interface{}) (int, error) <span class="cov8" title="1">{
        values, err := attrMap.GetAttributeByAddress(address.Address, frames[address.ParentParameterIndex])
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span> else<span class="cov8" title="1"> {
                kind := reflect.ValueOf(values).Kind()
                if kind == reflect.Slice </span><span class="cov8" title="1">{
                        return len(values.([]interface{})), nil
                }</span> else<span class="cov0" title="0"> {
                        return 0, fmt.Errorf(
                                "unexpected element value kind %d for Path %s",
                                kind, attrMap.DictRec.AddressToFullPath(address.Address))
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package types

import (
        "errors"
        "fmt"
        "github.com/atlasgurus/rulestone/immutable"
        "github.com/zyedidia/generic/hashmap"
        "github.com/zyedidia/generic/hashset"
        "sync"
)

type Category int32

const MinCategory = Category(0)
const MaxCategory = Category(1000000000)

type Mask int64

func (v Category) GetHash() uint64 <span class="cov8" title="1">{
        return uint64(v)
}</span>

func (v Category) Equals(element immutable.SetElement) bool <span class="cov8" title="1">{
        return v == element.(Category)
}</span>

type AndOrSet immutable.Set[immutable.Set[Category]]

func (set AndOrSet) GetHash() uint64 <span class="cov8" title="1">{
        return immutable.Set[immutable.Set[Category]](set).GetHash()
}</span>

func (set AndOrSet) Equals(element immutable.SetElement) bool <span class="cov8" title="1">{
        return immutable.Set[immutable.Set[Category]](set).Equals(element)
}</span>

func (set AndOrSet) Union(a AndOrSet) AndOrSet <span class="cov8" title="1">{
        return AndOrSet(immutable.Set[immutable.Set[Category]](set).Union(immutable.Set[immutable.Set[Category]](a)))
}</span>

func (set AndOrSet) Each(fn func(key immutable.Set[Category])) <span class="cov8" title="1">{
        immutable.Set[immutable.Set[Category]](set).Each(fn)
}</span>

func (set AndOrSet) Size() int <span class="cov8" title="1">{
        result := 0
        immutable.Set[immutable.Set[Category]](set).Each(func(key immutable.Set[Category]) </span><span class="cov8" title="1">{
                result++
        }</span>)
        <span class="cov8" title="1">return result</span>
}

func (set AndOrSet) ToSlice() []immutable.Set[Category] <span class="cov8" title="1">{
        return immutable.Set[immutable.Set[Category]](set).ToSlice()
}</span>

func (set AndOrSet) ToSlices() [][]Category <span class="cov0" title="0">{
        return MapSlice[immutable.Set[Category], []Category](
                immutable.Set[immutable.Set[Category]](set).ToSlice(), func(set immutable.Set[Category]) []Category </span><span class="cov0" title="0">{
                        return set.ToSlice()
                }</span>)
}

func AndOrSetFromSlices(slices [][]Category) AndOrSet <span class="cov0" title="0">{
        return AndOrSet(SliceToSet(MapSlice(slices, func(c []Category) immutable.Set[Category] </span><span class="cov0" title="0">{
                return SliceToSet(c)
        }</span>)))
}

func (set AndOrSet) Difference(a AndOrSet) AndOrSet <span class="cov0" title="0">{
        return AndOrSet(immutable.Set[immutable.Set[Category]](set).Difference(immutable.Set[immutable.Set[Category]](a)))
}</span>

func SliceToAndOrSet(s []Category) AndOrSet <span class="cov0" title="0">{
        return AndOrSet(SliceToSetOfSets[Category](s))
}</span>

func SliceToSet[K immutable.SetElement](s []K) immutable.Set[K] <span class="cov0" title="0">{
        return *immutable.Of[K](s...)
}</span>

func SliceToSetOfSets[K immutable.SetElement](s []K) immutable.Set[immutable.Set[K]] <span class="cov0" title="0">{
        var andSetSlice []immutable.Set[K]
        for _, v := range s </span><span class="cov0" title="0">{
                andSetSlice = append(andSetSlice, *immutable.Of[K](v))
        }</span>
        <span class="cov0" title="0">return *immutable.Of[immutable.Set[K]](andSetSlice...)</span>
}

func (set AndOrSet) ToHashSet() hashset.Set[immutable.Set[Category]] <span class="cov8" title="1">{
        return immutable.Set[immutable.Set[Category]](set).ToHashSet()
}</span>

func NewHashSet[K immutable.SetElement]() *hashset.Set[K] <span class="cov8" title="1">{
        return hashset.New[K](0, func(a, b K) bool </span><span class="cov8" title="1">{ return a.Equals(b) }</span>, K.GetHash)
}

func NewHashMap[K immutable.SetElement, T any]() *hashmap.Map[K, T] <span class="cov8" title="1">{
        return hashmap.New[K, T](0, func(a, b K) bool </span><span class="cov8" title="1">{ return a.Equals(b) }</span>, K.GetHash)
}

var EmptyAndOrSet = AndOrSet(*immutable.Of[immutable.Set[Category]]())

func Reduce[T, M any](s []T, f func(M, T) M, initValue M) M <span class="cov8" title="1">{
        acc := initValue
        for _, v := range s </span><span class="cov8" title="1">{
                acc = f(acc, v)
        }</span>
        <span class="cov8" title="1">return acc</span>
}

func FilterSlice[T any](a []T, f func(T) bool) []T <span class="cov8" title="1">{
        n := make([]T, 0)
        for _, e := range a </span><span class="cov8" title="1">{
                if f(e) </span><span class="cov8" title="1">{
                        n = append(n, e)
                }</span>
        }
        <span class="cov8" title="1">return n</span>
}

func FindFirstInSlice[T any](a []T, f func(T) bool) *T <span class="cov8" title="1">{
        for _, e := range a </span><span class="cov8" title="1">{
                if f(e) </span><span class="cov0" title="0">{
                        return &amp;e
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func MapSlice[T any, M any](a []T, f func(T) M) []M <span class="cov8" title="1">{
        n := make([]M, len(a))
        for i, e := range a </span><span class="cov8" title="1">{
                n[i] = f(e)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func SliceToBoolMap[T comparable](s []T) map[T]bool <span class="cov0" title="0">{
        result := make(map[T]bool, len(s))
        for _, v := range s </span><span class="cov0" title="0">{
                result[v] = true
        }</span>
        <span class="cov0" title="0">return result</span>
}

type ErrorLog struct {
        errors []error
}

type AppContext struct {
        errLog ErrorLog
}

func (ctx *AppContext) LogError(err error) error <span class="cov0" title="0">{
        ctx.errLog.LogError(err)
        return err
}</span>

func (ctx *AppContext) NewError(err string) error <span class="cov0" title="0">{
        result := errors.New(err)
        ctx.errLog.LogError(result)
        return result
}</span>

func (errLog *ErrorLog) LogError(err error) <span class="cov0" title="0">{
        errLog.errors = append(errLog.errors, err)
}</span>

func (ctx *AppContext) Errorf(format string, a ...any) error <span class="cov0" title="0">{
        result := fmt.Errorf(format, a...)
        return ctx.LogError(result)
}</span>

func (errLog *ErrorLog) PrintErrors() <span class="cov0" title="0">{
        for _, err := range errLog.errors </span><span class="cov0" title="0">{
                fmt.Println(err)
        }</span>
}

func (ctx *AppContext) PrintErrors() <span class="cov0" title="0">{
        ctx.errLog.PrintErrors()
}</span>

func (ctx *AppContext) NumErrors() int <span class="cov8" title="1">{
        return len(ctx.errLog.errors)
}</span>

func (ctx *AppContext) GetError(index int) error <span class="cov0" title="0">{
        return ctx.errLog.errors[index]
}</span>

func NewAppContext() *AppContext <span class="cov8" title="1">{
        return &amp;AppContext{}
}</span>

const MaxIntSliceCapacity = 20

var intSlicePool = sync.Pool{
        New: func() interface{} <span class="cov8" title="1">{
                return make([]int, 0, MaxIntSliceCapacity) // Allocate a slice with a capacity of maxCapacity
        }</span>,
}

func GetIntSlice() []int <span class="cov8" title="1">{
        return intSlicePool.Get().([]int)
}</span>

func PutIntSlice(v []int) <span class="cov8" title="1">{
        intSlicePool.Put(v[:0])
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package utils

import (
        "bufio"
        "encoding/json"
        "fmt"
        "gopkg.in/yaml.v3"
        "io"
        "os"
        "path/filepath"
        "strings"
)

type EventGenerator struct {
        dec *json.Decoder
}

func NewEventGenerator(input io.Reader) *EventGenerator <span class="cov0" title="0">{
        return &amp;EventGenerator{dec: json.NewDecoder(input)}
}</span>

func (gen *EventGenerator) Next() interface{} <span class="cov0" title="0">{
        var result interface{}
        if err := gen.dec.Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return result</span>
}

func ReadEvent(path string) (interface{}, error) <span class="cov8" title="1">{
        if f, err := os.Open(path); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span> else<span class="cov8" title="1"> {
                defer f.Close()
                fileType := filepath.Ext(path)
                fileType = fileType[1:] // Remove the dot from the extension
                var result interface{}
                switch strings.ToLower(fileType) </span>{
                case "json":<span class="cov8" title="1">
                        decoder := json.NewDecoder(f)
                        if err := decoder.Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("error parsing JSON:%s", err)
                        }</span> else<span class="cov8" title="1"> {
                                return result, nil
                        }</span>
                case "yaml", "yml":<span class="cov8" title="1">
                        decoder := yaml.NewDecoder(f)
                        if err := decoder.Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("error parsing YAML:%s", err)
                        }</span> else<span class="cov8" title="1"> {
                                return result, nil
                        }</span>
                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("unsupported file type:%s", fileType)</span>
                }
        }
}

func ReadEvents(path string, callback func(interface{}) error) error <span class="cov0" title="0">{
        file, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        scanner := bufio.NewScanner(file)
        for scanner.Scan() </span><span class="cov0" title="0">{
                var result interface{}
                line := scanner.Text()

                err := json.Unmarshal([]byte(line), &amp;result)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Call the callback function for each object
                <span class="cov0" title="0">err = callback(result)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
